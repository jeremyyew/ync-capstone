Nat.t:
  Set
Nat.two:
  nat
Nat.one:
  nat
Nat.zero:
  nat
Nat.sqrt_up:
  nat ->
  nat
Nat.double:
  nat ->
  nat
Nat.Even:
  nat ->
  Prop
Nat.ones:
  nat ->
  nat
Nat.log2:
  nat ->
  nat
Nat.log2_up:
  nat ->
  nat
Nat.sqrt:
  nat ->
  nat
Nat.pred:
  nat ->
  nat
Nat.square:
  nat ->
  nat
Nat.Odd:
  nat ->
  Prop
Nat.div2:
  nat ->
  nat
Nat.succ:
  nat ->
  nat
Nat.pow:
  nat ->
  nat ->
  nat
Nat.clearbit:
  nat ->
  nat ->
  nat
Nat.lnot:
  nat ->
  nat ->
  nat
Nat.ldiff:
  nat ->
  nat ->
  nat
Nat.lor:
  nat ->
  nat ->
  nat
Nat.lt_alt:
  nat ->
  nat ->
  Prop
Nat.modulo:
  nat ->
  nat ->
  nat
Nat.eq:
  nat ->
  nat ->
  Prop
Nat.divide:
  nat ->
  nat ->
  Prop
Nat.gcd:
  nat ->
  nat ->
  nat
Nat.le_alt:
  nat ->
  nat ->
  Prop
Nat.div:
  nat ->
  nat ->
  nat
Nat.setbit:
  nat ->
  nat ->
  nat
Nat.lt:
  nat ->
  nat ->
  Prop
Nat.max:
  nat ->
  nat ->
  nat
Nat.sub:
  nat ->
  nat ->
  nat
Nat.mul:
  nat ->
  nat ->
  nat
Nat.min:
  nat ->
  nat ->
  nat
Nat.lxor:
  nat ->
  nat ->
  nat
Nat.tail_mul:
  nat ->
  nat ->
  nat
Nat.le:
  nat ->
  nat ->
  Prop
Nat.lcm:
  nat ->
  nat ->
  nat
Nat.add:
  nat ->
  nat ->
  nat
Nat.tail_add:
  nat ->
  nat ->
  nat
Nat.land:
  nat ->
  nat ->
  nat
Nat.odd:
  nat ->
  bool
Nat.even:
  nat ->
  bool
Nat.to_uint:
  nat ->
  Decimal.uint
Nat.b2n:
  bool ->
  nat
Nat.of_uint:
  Decimal.uint ->
  nat
Nat.to_int:
  nat ->
  Decimal.int
Nat.Bezout:
  nat ->
  nat ->
  nat ->
  Prop
Nat.tail_addmul:
  nat ->
  nat ->
  nat ->
  nat
Nat.leb:
  nat ->
  nat ->
  bool
Nat.of_uint_acc:
  Decimal.uint ->
  nat ->
  nat
Nat.compare:
  nat ->
  nat ->
  comparison
Nat.to_little_uint:
  nat ->
  Decimal.uint ->
  Decimal.uint
Nat.testbit:
  nat ->
  nat ->
  bool
Nat.eqb:
  nat ->
  nat ->
  bool
Nat.ltb:
  nat ->
  nat ->
  bool
Nat.le_refl:
  forall
   n : nat,
  n <=
  n
Nat.sqrt_iter:
  nat ->
  nat ->
  nat ->
  nat ->
  nat
Nat.divide_refl:
  forall
   n : nat,
  Nat.divide
   n
   n
Nat.log2_iter:
  nat ->
  nat ->
  nat ->
  nat ->
  nat
Nat.divide_reflexive:
  RelationClasses.Reflexive
   Nat.divide
Nat.divide_transitive:
  RelationClasses.Transitive
   Nat.divide
Nat.le_preorder:
  RelationClasses.PreOrder
   le
Nat.lt_wf_0:
  well_founded
   lt
Nat.lt_strorder:
  RelationClasses.StrictOrder
   lt
Nat.iter:
  nat ->
  forall
   A : Type,
  (A ->
   A) ->
  A ->
  A
Nat.of_int:
  Decimal.int ->
  option
   nat
Nat.lt_0_1:
  0 <
  1
Nat.eq_trans:
  RelationClasses.Transitive
   eq
Nat.eq_equiv:
  RelationClasses.Equivalence
   eq
Nat.eqf:
  (nat ->
   bool) ->
  (nat ->
   bool) ->
  Prop
Nat.eq_sym:
  RelationClasses.Symmetric
   eq
Nat.le_0_1:
  0 <=
  1
Nat.divide_0_r:
  forall
   n : nat,
  Nat.divide
   n
   0
Nat.eq_refl:
  RelationClasses.Reflexive
   eq
Nat.le_0_l:
  forall
   n : nat,
  0 <=
  n
Nat.recursion:
  forall
   A : Type,
  A ->
  (nat ->
   A ->
   A) ->
  nat ->
  A
Nat.lt_succ_diag_r:
  forall
   n : nat,
  n <
  S n
Nat.le_pred_l:
  forall
   n : nat,
  Nat.pred
   n <=
  n
Nat.lt_irrefl:
  forall
   x : nat,
  ~
  x <
  x
Nat.lt_0_2:
  0 <
  2
Nat.le_0_2:
  0 <=
  2
Nat.le_succ_diag_r:
  forall
   n : nat,
  n <=
  S n
Nat.sqrt_le_lin:
  forall
   a : nat,
  Nat.sqrt
   a <=
  a
Nat.divmod:
  nat ->
  nat ->
  nat ->
  nat ->
  nat *
  nat
Nat.eqf_equiv:
  RelationClasses.Equivalence
   Nat.eqf
Nat.bitwise:
  (bool ->
   bool ->
   bool) ->
  nat ->
  nat ->
  nat ->
  nat
Nat.lt_1_2:
  1 <
  2
Nat.shiftl:
  (fun
   _ : nat
   =>
   nat)
   0 ->
  forall
   n : nat,
  (fun
   _ : nat
   =>
   nat)
   n
Nat.max_id:
  forall
   n : nat,
  Nat.max
   n
   n =
  n
Nat.lor_diag:
  forall
   a : nat,
  Nat.lor
   a
   a =
  a
Nat.sqrt_0:
  Nat.sqrt
   0 =
  0
Nat.lt_decidable:
  forall
   n
   m : nat,
  Decidable.decidable
   (n <
   m)
Nat.shiftr:
  (fun
   _ : nat
   =>
   nat)
   0 ->
  forall
   n : nat,
  (fun
   _ : nat
   =>
   nat)
   n
Nat.min_id:
  forall
   n : nat,
  Nat.min
   n
   n =
  n
Nat.gcd_diag:
  forall
   n : nat,
  Nat.gcd
   n
   n =
  n
Nat.le_decidable:
  forall
   n
   m : nat,
  Decidable.decidable
   (n <=
   m)
Nat.land_diag:
  forall
   a : nat,
  Nat.land
   a
   a =
  a
Nat.sqrt_up_0:
  Nat.sqrt_up
   0 =
  0
Nat.pred_0:
  Nat.pred
   0 =
  0
Nat.lcm_diag:
  forall
   n : nat,
  Nat.lcm
   n
   n =
  n
Nat.le_sub_l:
  forall
   n
   m : nat,
  n -
  m <=
  n
Nat.divide_1_l:
  forall
   n : nat,
  Nat.divide
   1
   n
Nat.divide_factor_r:
  forall
   n
   m : nat,
  Nat.divide
   n
   (m *
   n)
Nat.le_min_l:
  forall
   n
   m : nat,
  Nat.min
   n
   m <=
  n
Nat.le_min_r:
  forall
   n
   m : nat,
  Nat.min
   n
   m <=
  m
Nat.le_add_r:
  forall
   n
   m : nat,
  n <=
  n +
  m
Nat.lt_0_succ:
  forall
   n : nat,
  0 <
  S n
Nat.sqrt_up_nonneg:
  forall
   a : nat,
  0 <=
  Nat.sqrt_up
   a
Nat.le_max_r:
  forall
   n
   m : nat,
  m <=
  Nat.max
   n
   m
Nat.gcd_divide_l:
  forall
   a
   b : nat,
  Nat.divide
   (Nat.gcd
   a
   b)
   a
Nat.divide_lcm_r:
  forall
   a
   b : nat,
  Nat.divide
   b
   (Nat.lcm
   a
   b)
Nat.eq_decidable:
  forall
   n
   m : nat,
  Decidable.decidable
   (n =
   m)
Nat.gcd_divide_r:
  forall
   a
   b : nat,
  Nat.divide
   (Nat.gcd
   a
   b)
   b
Nat.nlt_0_r:
  forall
   n : nat,
  ~
  n <
  0
Nat.log2_up_nonneg:
  forall
   a : nat,
  0 <=
  Nat.log2_up
   a
Nat.divide_factor_l:
  forall
   n
   m : nat,
  Nat.divide
   n
   (n *
   m)
Nat.le_max_l:
  forall
   n
   m : nat,
  n <=
  Nat.max
   n
   m
Nat.divide_lcm_l:
  forall
   a
   b : nat,
  Nat.divide
   a
   (Nat.lcm
   a
   b)
Nat.log2_nonneg:
  forall
   a : nat,
  0 <=
  Nat.log2
   a
Nat.neq_0:
  ~
  (forall
   n : nat,
   n =
   0)
Nat.one_succ:
  1 =
  1
Nat.square_nonneg:
  forall
   a : nat,
  0 <=
  a *
  a
Nat.lt_le_incl:
  forall
   n
   m : nat,
  n <
  m ->
  n <=
  m
Nat.min_0_l:
  forall
   n : nat,
  Nat.min
   0
   n =
  0
Nat.max_0_r:
  forall
   n : nat,
  Nat.max
   n
   0 =
  n
Nat.lcm_0_r:
  forall
   n : nat,
  Nat.lcm
   n
   0 =
  0
Nat.land_0_l:
  forall
   a : nat,
  Nat.land
   0
   a =
  0
Nat.sub_0_l:
  forall
   n : nat,
  0 -
  n =
  0
Nat.lt_lt_0:
  forall
   n
   m : nat,
  n <
  m ->
  0 <
  m
Nat.shiftr_0_r:
  forall
   a : nat,
  Nat.shiftr
   a
   0 =
  a
Nat.even_0:
  Nat.even
   0 =
  true
Nat.le_sqrt_sqrt_up:
  forall
   a : nat,
  Nat.sqrt
   a <=
  Nat.sqrt_up
   a
Nat.lor_0_r:
  forall
   a : nat,
  Nat.lor
   a
   0 =
  a
Nat.lor_0_l:
  forall
   a : nat,
  Nat.lor
   0
   a =
  a
Nat.lcm_0_l:
  forall
   n : nat,
  Nat.lcm
   0
   n =
  0
Nat.shiftr_0_l:
  forall
   n : nat,
  Nat.shiftr
   0
   n =
  0
Nat.ldiff_0_r:
  forall
   a : nat,
  Nat.ldiff
   a
   0 =
  a
Nat.ldiff_0_l:
  forall
   a : nat,
  Nat.ldiff
   0
   a =
  0
Nat.shiftl_0_r:
  forall
   a : nat,
  Nat.shiftl
   a
   0 =
  a
Nat.lxor_nilpotent:
  forall
   a : nat,
  Nat.lxor
   a
   a =
  0
Nat.gcd_0_l:
  forall
   n : nat,
  Nat.gcd
   0
   n =
  n
Nat.land_0_r:
  forall
   a : nat,
  Nat.land
   a
   0 =
  0
Nat.nlt_succ_diag_l:
  forall
   n : nat,
  ~
  S n <
  n
Nat.le_div2:
  forall
   n : nat,
  Nat.div2
   (S
   n) <=
  n
Nat.shiftl_0_l:
  forall
   n : nat,
  Nat.shiftl
   0
   n =
  0
Nat.mul_0_r:
  forall
   n : nat,
  n *
  0 =
  0
Nat.min_0_r:
  forall
   n : nat,
  Nat.min
   n
   0 =
  0
Nat.mul_0_l:
  forall
   n : nat,
  0 *
  n =
  0
Nat.lxor_0_r:
  forall
   a : nat,
  Nat.lxor
   a
   0 =
  a
Nat.sub_0_r:
  forall
   n : nat,
  n -
  0 =
  n
Nat.le_log2_log2_up:
  forall
   a : nat,
  Nat.log2
   a <=
  Nat.log2_up
   a
Nat.add_0_l:
  forall
   n : nat,
  0 +
  n =
  n
Nat.lxor_0_l:
  forall
   a : nat,
  Nat.lxor
   0
   a =
  a
Nat.gcd_0_r:
  forall
   n : nat,
  Nat.gcd
   n
   0 =
  n
Nat.add_0_r:
  forall
   n : nat,
  n +
  0 =
  n
Nat.nle_succ_diag_l:
  forall
   n : nat,
  ~
  S n <=
  n
Nat.max_0_l:
  forall
   n : nat,
  Nat.max
   0
   n =
  n
Nat.ldiff_diag:
  forall
   a : nat,
  Nat.ldiff
   a
   a =
  0
Nat.odd_0:
  Nat.odd
   0 =
  false
Nat.sub_diag:
  forall
   n : nat,
  n -
  n =
  0
Nat.Even_or_Odd:
  forall
   x : nat,
  Nat.Even
   x \/
  Nat.Odd
   x
Nat.le_alt_dichotomy:
  forall
   n
   m : nat,
  Nat.le_alt
   n
   m \/
  Nat.le_alt
   m
   n
Nat.neq_succ_diag_l:
  forall
   n : nat,
  S n <>
  n
Nat.neq_succ_diag_r:
  forall
   n : nat,
  n <>
  S n
Nat.eq_le_incl:
  forall
   n
   m : nat,
  n =
  m ->
  n <=
  m
Nat.le_ge_cases:
  forall
   n
   m : nat,
  n <=
  m \/
  m <=
  n
Nat.gcd_nonneg:
  forall
   a
   b : nat,
  0 <=
  Nat.gcd
   a
   b
Nat.pred_succ:
  forall
   n : nat,
  Nat.pred
   (S
   n) =
  n
Nat.Even_Odd_False:
  forall
   x : nat,
  Nat.Even
   x ->
  Nat.Odd
   x ->
  False
Nat.le_le_pred:
  forall
   n
   m : nat,
  n <=
  m ->
  Nat.pred
   n <=
  m
Nat.square_spec:
  forall
   n : nat,
  Nat.square
   n =
  n *
  n
Nat.lor_comm:
  forall
   a
   b : nat,
  Nat.lor
   a
   b =
  Nat.lor
   b
   a
Nat.le_le_succ_r:
  forall
   n
   m : nat,
  n <=
  m ->
  n <=
  S m
Nat.min_comm:
  forall
   n
   m : nat,
  Nat.min
   n
   m =
  Nat.min
   m
   n
Nat.max_comm:
  forall
   n
   m : nat,
  Nat.max
   n
   m =
  Nat.max
   m
   n
Nat.sqrt_square:
  forall
   a : nat,
  Nat.sqrt
   (a *
   a) =
  a
Nat.lt_lt_pred:
  forall
   n
   m : nat,
  n <
  m ->
  Nat.pred
   n <
  m
Nat.lnot_involutive:
  forall
   a
   n : nat,
  Nat.lnot
   (Nat.lnot
   a
   n)
   n =
  a
Nat.log2_1:
  Nat.log2
   1 =
  0
Nat.lt_lt_succ_r:
  forall
   n
   m : nat,
  n <
  m ->
  n <
  S m
Nat.gcd_comm:
  forall
   n
   m : nat,
  Nat.gcd
   n
   m =
  Nat.gcd
   m
   n
PeanoNat.Nat.pred_wd_obligation_1:
  Morphisms.respectful
   eq
   eq
   Nat.pred
   Nat.pred
Nat.log2_up_1:
  Nat.log2_up
   1 =
  0
PeanoNat.Nat.succ_wd_obligation_1:
  Morphisms.respectful
   eq
   eq
   S
   S
Nat.le_pred_le:
  forall
   n
   m : nat,
  n <=
  Nat.pred
   m ->
  n <=
  m
Nat.lt_asymm:
  forall
   n
   m : nat,
  n <
  m ->
  ~
  m <
  n
Nat.land_comm:
  forall
   a
   b : nat,
  Nat.land
   a
   b =
  Nat.land
   b
   a
Nat.divide_0_l:
  forall
   n : nat,
  Nat.divide
   0
   n ->
  n =
  0
Nat.add_comm:
  forall
   n
   m : nat,
  n +
  m =
  m +
  n
Nat.lt_pred_lt:
  forall
   n
   m : nat,
  n <
  Nat.pred
   m ->
  n <
  m
Nat.mul_comm:
  forall
   n
   m : nat,
  n *
  m =
  m *
  n
Nat.lt_succ_l:
  forall
   n
   m : nat,
  S n <
  m ->
  n <
  m
Nat.lcm_comm:
  forall
   a
   b : nat,
  Nat.lcm
   a
   b =
  Nat.lcm
   b
   a
Nat.lxor_comm:
  forall
   a
   b : nat,
  Nat.lxor
   a
   b =
  Nat.lxor
   b
   a
Nat.log2_lt_lin:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2
   a <
  a
Nat.log2_up_le_lin:
  forall
   a : nat,
  0 <=
  a ->
  Nat.log2_up
   a <=
  a
Nat.two_succ:
  2 =
  2
Nat.compare_refl:
  forall
   x : nat,
  (x
   ?= x) =
  Eq
Nat.eq_sym_iff:
  forall
   x
   y : nat,
  x =
  y <->
  y =
  x
Nat.log2_le_lin:
  forall
   a : nat,
  0 <=
  a ->
  Nat.log2
   a <=
  a
Nat.eqb_refl:
  forall
   x : nat,
  (x =?
   x) =
  true
Nat.sqrt_up_le_lin:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt_up
   a <=
  a
Nat.log2_up_lt_lin:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2_up
   a <
  a
Nat.nle_succ_0:
  forall
   n : nat,
  ~
  S n <=
  0
Nat.lt_div2:
  forall
   n : nat,
  0 <
  n ->
  Nat.div2
   n <
  n
Nat.ltb_irrefl:
  forall
   x : nat,
  (x <?
   x) =
  false
Nat.leb_refl:
  forall
   x : nat,
  (x <=?
   x) =
  true
Nat.sqrt_up_le_mono:
  forall
   a
   b : nat,
  a <=
  b ->
  Nat.sqrt_up
   a <=
  Nat.sqrt_up
   b
Nat.sub_add_le:
  forall
   n
   m : nat,
  n <=
  n -
  m +
  m
Nat.sqrt_lt_cancel:
  forall
   a
   b : nat,
  Nat.sqrt
   a <
  Nat.sqrt
   b ->
  a <
  b
Nat.log2_up_le_mono:
  forall
   a
   b : nat,
  a <=
  b ->
  Nat.log2_up
   a <=
  Nat.log2_up
   b
Nat.Odd_succ_succ:
  forall
   n : nat,
  Nat.Odd
   (S
   (S
   n)) <->
  Nat.Odd
   n
Nat.Even_succ_succ:
  forall
   n : nat,
  Nat.Even
   (S
   (S
   n)) <->
  Nat.Even
   n
Nat.sqrt_up_1:
  Nat.sqrt_up
   1 =
  1
Nat.sqrt_up_lt_cancel:
  forall
   a
   b : nat,
  Nat.sqrt_up
   a <
  Nat.sqrt_up
   b ->
  a <
  b
Nat.le_trans:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  m <=
  p ->
  n <=
  p
Nat.lt_trans:
  forall
   n
   m
   p : nat,
  n <
  m ->
  m <
  p ->
  n <
  p
Nat.sqrt_1:
  Nat.sqrt
   1 =
  1
Nat.lt_ge_cases:
  forall
   n
   m : nat,
  n <
  m \/
  m <=
  n
Nat.log2_succ_le:
  forall
   a : nat,
  Nat.log2
   (S
   a) <=
  S
   (Nat.log2
   a)
Nat.leb_spec0:
  forall
   x
   y : nat,
  reflect
   (x <=
   y)
   (x <=?
   y)
Nat.neq_0_succ:
  forall
   n : nat,
  0 <>
  S n
Nat.sqrt_le_mono:
  forall
   a
   b : nat,
  a <=
  b ->
  Nat.sqrt
   a <=
  Nat.sqrt
   b
Nat.le_equiv:
  forall
   n
   m : nat,
  Nat.le_alt
   n
   m <->
  n <=
  m
Nat.neq_succ_0:
  forall
   n : nat,
  S n <>
  0
Nat.log2_up_lt_cancel:
  forall
   a
   b : nat,
  Nat.log2_up
   a <
  Nat.log2_up
   b ->
  a <
  b
Nat.log2_le_mono:
  forall
   a
   b : nat,
  a <=
  b ->
  Nat.log2
   a <=
  Nat.log2
   b
Nat.sqrt_succ_le:
  forall
   a : nat,
  Nat.sqrt
   (S
   a) <=
  S
   (Nat.sqrt
   a)
Nat.divide_trans:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   m
   p ->
  Nat.divide
   n
   p
Nat.log2_lt_cancel:
  forall
   a
   b : nat,
  Nat.log2
   a <
  Nat.log2
   b ->
  a <
  b
Nat.lt_equiv:
  forall
   n
   m : nat,
  Nat.lt_alt
   n
   m <->
  n <
  m
Nat.log2_up_succ_le:
  forall
   a : nat,
  Nat.log2_up
   (S
   a) <=
  S
   (Nat.log2_up
   a)
Nat.ltb_spec0:
  forall
   x
   y : nat,
  reflect
   (x <
   y)
   (x <?
   y)
Nat.pred_le_mono:
  forall
   n
   m : nat,
  n <=
  m ->
  Nat.pred
   n <=
  Nat.pred
   m
Nat.le_gt_cases:
  forall
   n
   m : nat,
  n <=
  m \/
  m <
  n
Nat.Even_succ:
  forall
   n : nat,
  Nat.Even
   (S
   n) <->
  Nat.Odd
   n
Nat.tail_mul_spec:
  forall
   n
   m : nat,
  Nat.tail_mul
   n
   m =
  n *
  m
Nat.add_sub:
  forall
   n
   m : nat,
  n +
  m -
  m =
  n
Nat.max_lub_l:
  forall
   n
   m
   p : nat,
  Nat.max
   n
   m <=
  p ->
  n <=
  p
Nat.lt_le_pred:
  forall
   n
   m : nat,
  n <
  m ->
  n <=
  Nat.pred
   m
Nat.odd_1:
  Nat.odd
   1 =
  true
Nat.max_lub_r:
  forall
   n
   m
   p : nat,
  Nat.max
   n
   m <=
  p ->
  m <=
  p
Nat.eqb_spec:
  forall
   x
   y : nat,
  reflect
   (x =
   y)
   (x =?
   y)
Nat.mul_1_l:
  forall
   n : nat,
  1 *
  n =
  n
Nat.lcm_1_l:
  forall
   n : nat,
  Nat.lcm
   1
   n =
  n
Nat.divide_mul_l:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   n
   (m *
   p)
Nat.lt_pred_le:
  forall
   n
   m : nat,
  Nat.pred
   n <
  m ->
  n <=
  m
Nat.even_1:
  Nat.even
   1 =
  false
Nat.lnot_0_l:
  forall
   n : nat,
  Nat.lnot
   0
   n =
  Nat.ones
   n
Nat.min_glb_l:
  forall
   n
   m
   p : nat,
  p <=
  Nat.min
   n
   m ->
  p <=
  n
Nat.mul_1_r:
  forall
   n : nat,
  n *
  1 =
  n
Nat.lcm_1_r:
  forall
   n : nat,
  Nat.lcm
   n
   1 =
  n
Nat.min_max_absorption:
  forall
   n
   m : nat,
  Nat.max
   n
   (Nat.min
   n
   m) =
  n
Nat.le_log2_up_succ_log2:
  forall
   a : nat,
  Nat.log2_up
   a <=
  S
   (Nat.log2
   a)
Nat.b2n_bit0:
  forall
   a0 : bool,
  Nat.testbit
   (Nat.b2n
   a0)
   0 =
  a0
Nat.mod_1_r:
  forall
   a : nat,
  a
  mod 1 =
  0
Nat.tail_add_spec:
  forall
   n
   m : nat,
  Nat.tail_add
   n
   m =
  n +
  m
Nat.max_min_absorption:
  forall
   n
   m : nat,
  Nat.min
   n
   (Nat.max
   n
   m) =
  n
Nat.le_sqrt_up_succ_sqrt:
  forall
   a : nat,
  Nat.sqrt_up
   a <=
  S
   (Nat.sqrt
   a)
Nat.lnot_ones:
  forall
   n : nat,
  Nat.lnot
   (Nat.ones
   n)
   n =
  0
Nat.lt_lt_add_r:
  forall
   n
   m
   p : nat,
  n <
  m ->
  n <
  m +
  p
Nat.eqb_sym:
  forall
   x
   y : nat,
  (x =?
   y) =
  (y =?
   x)
Nat.pow_0_r:
  forall
   a : nat,
  a
  ^ 0 =
  1
Nat.lt_lt_add_l:
  forall
   n
   m
   p : nat,
  n <
  m ->
  n <
  p +
  m
Nat.pow_1_r:
  forall
   a : nat,
  a
  ^ 1 =
  a
Nat.div_1_r:
  forall
   a : nat,
  a /
  1 =
  a
Nat.min_glb_r:
  forall
   n
   m
   p : nat,
  p <=
  Nat.min
   n
   m ->
  p <=
  m
Nat.divide_mul_r:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   p ->
  Nat.divide
   n
   (m *
   p)
Nat.Odd_succ:
  forall
   n : nat,
  Nat.Odd
   (S
   n) <->
  Nat.Even
   n
Nat.le_partialorder:
  RelationClasses.PartialOrder
   eq
   le
Nat.eq_0_gt_0_cases:
  forall
   n : nat,
  n =
  0 \/
  0 <
  n
Nat.neq_sym:
  forall
   n
   m : nat,
  n <>
  m ->
  m <>
  n
Nat.bits_0:
  forall
   n : nat,
  Nat.testbit
   0
   n =
  false
Nat.log2_2:
  Nat.log2
   2 =
  1
Nat.max_case:
  forall
   (n
   m : nat)
   (P : 
   nat ->
   Type),
  P n ->
  P m ->
  P
   (Nat.max
   n
   m)
Nat.lt_add_pos_l:
  forall
   n
   m : nat,
  0 <
  n ->
  m <
  n +
  m
Nat.lt_neq:
  forall
   n
   m : nat,
  n <
  m ->
  n <>
  m
Nat.log2_up_2:
  Nat.log2_up
   2 =
  1
Nat.add_pos_l:
  forall
   n
   m : nat,
  0 <
  n ->
  0 <
  n +
  m
Nat.le_0_r:
  forall
   n : nat,
  n <=
  0 <->
  n =
  0
Nat.sqrt_2:
  Nat.sqrt
   2 =
  1
Nat.add_pos_r:
  forall
   n
   m : nat,
  0 <
  m ->
  0 <
  n +
  m
Nat.lt_add_pos_r:
  forall
   n
   m : nat,
  0 <
  n ->
  m <
  m +
  n
Nat.succ_inj:
  forall
   n1
   n2 : nat,
  S
   n1 =
  S
   n2 ->
  n1 =
  n2
Nat.divide_antisym:
  forall
   n
   m : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   m
   n ->
  n =
  m
Nat.min_case:
  forall
   (n
   m : nat)
   (P : 
   nat ->
   Type),
  P n ->
  P m ->
  P
   (Nat.min
   n
   m)
Nat.testbit_0_l:
  forall
   n : nat,
  Nat.testbit
   0
   n =
  false
Nat.le_antisymm:
  forall
   n
   m : nat,
  n <=
  m ->
  m <=
  n ->
  n =
  m
Nat.min_r:
  forall
   n
   m : nat,
  m <=
  n ->
  Nat.min
   n
   m =
  m
Nat.min_l:
  forall
   n
   m : nat,
  n <=
  m ->
  Nat.min
   n
   m =
  n
Nat.sqrt_up_eqn0:
  forall
   a : nat,
  a <=
  0 ->
  Nat.sqrt_up
   a =
  0
Nat.gcd_1_r:
  forall
   n : nat,
  Nat.gcd
   n
   1 =
  1
Nat.log2_up_nonpos:
  forall
   a : nat,
  a <=
  0 ->
  Nat.log2_up
   a =
  0
Nat.odd_2:
  Nat.odd
   2 =
  false
Nat.even_2:
  Nat.even
   2 =
  true
Nat.mod_small:
  forall
   a
   b : nat,
  a <
  b ->
  a
  mod b =
  a
Nat.log2_nonpos:
  forall
   n : nat,
  n <=
  0 ->
  Nat.log2
   n =
  0
Nat.le_lt_trans:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  m <
  p ->
  n <
  p
Nat.add_1_r:
  forall
   n : nat,
  n +
  1 =
  S n
Nat.add_1_l:
  forall
   n : nat,
  1 +
  n =
  S n
Nat.eq_stepl:
  forall
   x
   y
   z : nat,
  x =
  y ->
  x =
  z ->
  z =
  y
Nat.div2_decr:
  forall
   a
   n : nat,
  a <=
  S n ->
  Nat.div2
   a <=
  n
Nat.max_r:
  forall
   n
   m : nat,
  n <=
  m ->
  Nat.max
   n
   m =
  m
Nat.max_l:
  forall
   n
   m : nat,
  m <=
  n ->
  Nat.max
   n
   m =
  n
Nat.gcd_1_l:
  forall
   n : nat,
  Nat.gcd
   1
   n =
  1
Nat.sqrt_neg:
  forall
   a : nat,
  a <
  0 ->
  Nat.sqrt
   a =
  0
Nat.divide_lcm_eq_r:
  forall
   n
   m : nat,
  Nat.divide
   n
   m ->
  Nat.lcm
   n
   m =
  m
Nat.lt_pred_lt_succ:
  forall
   n
   m : nat,
  Nat.pred
   n <
  m ->
  n <
  S m
Nat.lt_le_trans:
  forall
   n
   m
   p : nat,
  n <
  m ->
  m <=
  p ->
  n <
  p
Nat.sqrt_up_pos:
  forall
   a : nat,
  0 <
  Nat.sqrt_up
   a <->
  0 <
  a
Nat.le_succ_le_pred:
  forall
   n
   m : nat,
  S n <=
  m ->
  n <=
  Nat.pred
   m
Nat.pow_1_l:
  forall
   a : nat,
  1
  ^ a =
  1
Nat.sqrt_up_2:
  Nat.sqrt_up
   2 =
  2
Nat.gcd_0_r_nonneg:
  forall
   n : nat,
  0 <=
  n ->
  Nat.gcd
   n
   0 =
  n
Nat.gcd_0_l_nonneg:
  forall
   n : nat,
  0 <=
  n ->
  Nat.gcd
   0
   n =
  n
Nat.bit0_odd:
  forall
   a : nat,
  Nat.testbit
   a
   0 =
  Nat.odd
   a
Nat.log2_up_pos:
  forall
   a : nat,
  1 <
  a ->
  0 <
  Nat.log2_up
   a
Nat.gcd_add_diag_r:
  forall
   n
   m : nat,
  Nat.gcd
   n
   (m +
   n) =
  Nat.gcd
   n
   m
Nat.min_le_compat_r:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  Nat.min
   n
   p <=
  Nat.min
   m
   p
Nat.min_le_compat_l:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  Nat.min
   p
   n <=
  Nat.min
   p
   m
Nat.lor_eq_0_l:
  forall
   a
   b : nat,
  Nat.lor
   a
   b =
  0 ->
  a =
  0
Nat.bits_inj:
  forall
   a
   b : nat,
  Nat.eqf
   (Nat.testbit
   a)
   (Nat.testbit
   b) ->
  a =
  b
Nat.le_stepr:
  forall
   x
   y
   z : nat,
  x <=
  y ->
  y =
  z ->
  x <=
  z
Nat.le_stepl:
  forall
   x
   y
   z : nat,
  x <=
  y ->
  x =
  z ->
  z <=
  y
Nat.lt_stepr:
  forall
   x
   y
   z : nat,
  x <
  y ->
  y =
  z ->
  x <
  z
Nat.lt_stepl:
  forall
   x
   y
   z : nat,
  x <
  y ->
  x =
  z ->
  z <
  y
Nat.gcd_diag_nonneg:
  forall
   n : nat,
  0 <=
  n ->
  Nat.gcd
   n
   n =
  n
Nat.sqrt_lt_lin:
  forall
   a : nat,
  1 <
  a ->
  Nat.sqrt
   a <
  a
Nat.log2_pos:
  forall
   a : nat,
  1 <
  a ->
  0 <
  Nat.log2
   a
Nat.succ_le_mono:
  forall
   n
   m : nat,
  n <=
  m <->
  S n <=
  S m
Nat.pow_le_mono_l:
  forall
   a
   b
   c : nat,
  a <=
  b ->
  a
  ^ c <=
  b
  ^ c
Nat.max_le_compat_r:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  Nat.max
   n
   p <=
  Nat.max
   m
   p
Nat.gcd_eq_0_r:
  forall
   n
   m : nat,
  Nat.gcd
   n
   m =
  0 ->
  m =
  0
Nat.odd_succ_succ:
  forall
   n : nat,
  Nat.odd
   (S
   (S
   n)) =
  Nat.odd
   n
Nat.even_succ_succ:
  forall
   n : nat,
  Nat.even
   (S
   (S
   n)) =
  Nat.even
   n
Nat.mul_divide_mono_r:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   (n *
   p)
   (m *
   p)
Nat.land_ldiff:
  forall
   a
   b : nat,
  Nat.land
   (Nat.ldiff
   a
   b)
   b =
  0
Nat.gcd_eq_0_l:
  forall
   n
   m : nat,
  Nat.gcd
   n
   m =
  0 ->
  n =
  0
Nat.succ_lt_mono:
  forall
   n
   m : nat,
  n <
  m <->
  S n <
  S m
Nat.mul_le_mono_r:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  n *
  p <=
  m *
  p
Nat.lxor_eq:
  forall
   a
   a' : nat,
  Nat.lxor
   a
   a' =
  0 ->
  a =
  a'
Nat.sub_le_mono_l:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  p -
  m <=
  p -
  n
Nat.mul_le_mono_l:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  p *
  n <=
  p *
  m
Nat.eq_dec:
  forall
   n
   m : nat,
  {n =
   m}
  +
  {n <>
   m}
Nat.max_le_compat_l:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  Nat.max
   p
   n <=
  Nat.max
   p
   m
Nat.mul_divide_mono_l:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   (p *
   n)
   (p *
   m)
Nat.le_dne:
  forall
   n
   m : nat,
  ~
  ~
  n <=
  m <->
  n <=
  m
Nat.lt_dne:
  forall
   n
   m : nat,
  ~
  ~
  n <
  m <->
  n <
  m
Nat.sub_le_mono_r:
  forall
   n
   m
   p : nat,
  n <=
  m ->
  n -
  p <=
  m -
  p
Nat.succ_add_discr:
  forall
   n
   m : nat,
  m <>
  S
   (n +
   m)
Nat.sqrt_up_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.sqrt_up
Nat.pred_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.pred
Nat.negb_odd:
  forall
   n : nat,
  negb
   (Nat.odd
   n) =
  Nat.even
   n
Nat.le_ngt:
  forall
   n
   m : nat,
  n <=
  m <->
  ~
  m <
  n
Nat.div2_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.div2
Nat.negb_even:
  forall
   n : nat,
  negb
   (Nat.even
   n) =
  Nat.odd
   n
Nat.ones_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.ones
Nat.add_succ_comm:
  forall
   n
   m : nat,
  S n +
  m =
  n +
  S m
Nat.sub_succ:
  forall
   n
   m : nat,
  S n -
  S m =
  n -
  m
Nat.add_succ_r:
  forall
   n
   m : nat,
  n +
  S m =
  S
   (n +
   m)
Nat.lt_nge:
  forall
   n
   m : nat,
  n <
  m <->
  ~
  m <=
  n
Nat.nle_gt:
  forall
   n
   m : nat,
  ~
  n <=
  m <->
  m <
  n
Nat.b2n_inj:
  forall
   a0
   b0 : bool,
  Nat.b2n
   a0 =
  Nat.b2n
   b0 ->
  a0 =
  b0
Nat.odd_succ:
  forall
   n : nat,
  Nat.odd
   (S
   n) =
  Nat.even
   n
Nat.le_succ_l:
  forall
   n
   m : nat,
  S n <=
  m <->
  n <
  m
Nat.lt_succ_r:
  forall
   n
   m : nat,
  n <
  S m <->
  n <=
  m
Nat.add_succ_l:
  forall
   n
   m : nat,
  S n +
  m =
  S
   (n +
   m)
Nat.log2_up_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.log2_up
Nat.divide_1_r:
  forall
   n : nat,
  Nat.divide
   n
   1 ->
  n =
  1
Nat.log2_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.log2
Nat.even_succ:
  forall
   n : nat,
  Nat.even
   (S
   n) =
  Nat.odd
   n
Nat.nlt_ge:
  forall
   n
   m : nat,
  ~
  n <
  m <->
  m <=
  n
Nat.succ_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   S
Nat.square_le_mono:
  forall
   n
   m : nat,
  n <=
  m <->
  n *
  n <=
  m *
  m
Nat.max_lub_lt:
  forall
   n
   m
   p : nat,
  n <
  p ->
  m <
  p ->
  Nat.max
   n
   m <
  p
Nat.lcm_assoc:
  forall
   n
   m
   p : nat,
  Nat.lcm
   n
   (Nat.lcm
   m
   p) =
  Nat.lcm
   (Nat.lcm
   n
   m)
   p
Nat.div_small:
  forall
   a
   b : nat,
  a <
  b ->
  a /
  b =
  0
Nat.compare_antisym:
  forall
   n
   m : nat,
  (m
   ?= n) =
  CompOpp
   (n
   ?= m)
Nat.lor_assoc:
  forall
   a
   b
   c : nat,
  Nat.lor
   a
   (Nat.lor
   b
   c) =
  Nat.lor
   (Nat.lor
   a
   b)
   c
Nat.min_glb:
  forall
   n
   m
   p : nat,
  p <=
  n ->
  p <=
  m ->
  p <=
  Nat.min
   n
   m
Nat.max_lub:
  forall
   n
   m
   p : nat,
  n <=
  p ->
  m <=
  p ->
  Nat.max
   n
   m <=
  p
Nat.Even_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   Nat.Even
Nat.divide_add_r:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   n
   p ->
  Nat.divide
   n
   (m +
   p)
Nat.max_assoc:
  forall
   m
   n
   p : nat,
  Nat.max
   m
   (Nat.max
   n
   p) =
  Nat.max
   (Nat.max
   m
   n)
   p
Nat.square_lt_mono:
  forall
   n
   m : nat,
  n <
  m <->
  n *
  n <
  m *
  m
Nat.pow_neg_r:
  forall
   a
   b : nat,
  b <
  0 ->
  a
  ^ b =
  0
Nat.sub_1_r:
  forall
   n : nat,
  n -
  1 =
  Nat.pred
   n
Nat.sqrt_up_add_le:
  forall
   a
   b : nat,
  Nat.sqrt_up
   (a +
   b) <=
  Nat.sqrt_up
   a +
  Nat.sqrt_up
   b
Nat.lcm_least:
  forall
   a
   b
   c : nat,
  Nat.divide
   a
   c ->
  Nat.divide
   b
   c ->
  Nat.divide
   (Nat.lcm
   a
   b)
   c
Nat.sqrt_mul_below:
  forall
   a
   b : nat,
  Nat.sqrt
   a *
  Nat.sqrt
   b <=
  Nat.sqrt
   (a *
   b)
Nat.divide_add_cancel_r:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   n
   (m +
   p) ->
  Nat.divide
   n
   p
Nat.gcd_bezout_pos:
  forall
   n
   m : nat,
  0 <
  n ->
  Nat.Bezout
   n
   m
   (Nat.gcd
   n
   m)
Nat.eq_square_0:
  forall
   n : nat,
  n *
  n =
  0 <->
  n =
  0
Nat.mul_shuffle0:
  forall
   n
   m
   p : nat,
  n *
  m *
  p =
  n *
  p *
  m
Nat.sqrt_up_lt_lin:
  forall
   a : nat,
  2 <
  a ->
  Nat.sqrt_up
   a <
  a
Nat.div2_spec:
  forall
   a : nat,
  Nat.div2
   a =
  Nat.shiftr
   a
   1
Nat.mul_assoc:
  forall
   n
   m
   p : nat,
  n *
  (m *
   p) =
  n *
  m *
  p
Nat.divide_sub_r:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   m ->
  Nat.divide
   n
   p ->
  Nat.divide
   n
   (m -
   p)
Nat.min_assoc:
  forall
   m
   n
   p : nat,
  Nat.min
   m
   (Nat.min
   n
   p) =
  Nat.min
   (Nat.min
   m
   n)
   p
Nat.gcd_assoc:
  forall
   n
   m
   p : nat,
  Nat.gcd
   n
   (Nat.gcd
   m
   p) =
  Nat.gcd
   (Nat.gcd
   n
   m)
   p
Nat.recursion_0:
  forall
   (A : Type)
   (a : A)
   (f : 
   nat ->
   A ->
   A),
  Nat.recursion
   a
   f
   0 =
  a
Nat.min_glb_lt:
  forall
   n
   m
   p : nat,
  p <
  n ->
  p <
  m ->
  p <
  Nat.min
   n
   m
Nat.succ_inj_wd:
  forall
   n1
   n2 : nat,
  S
   n1 =
  S
   n2 <->
  n1 =
  n2
Nat.land_assoc:
  forall
   a
   b
   c : nat,
  Nat.land
   a
   (Nat.land
   b
   c) =
  Nat.land
   (Nat.land
   a
   b)
   c
Nat.Odd_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   Nat.Odd
Nat.add_assoc:
  forall
   n
   m
   p : nat,
  n +
  (m +
   p) =
  n +
  m +
  p
Nat.gcd_divide:
  forall
   a
   b : nat,
  Nat.divide
   (Nat.gcd
   a
   b)
   a /\
  Nat.divide
   (Nat.gcd
   a
   b)
   b
Nat.lt_1_l:
  forall
   n
   m : nat,
  0 <
  n ->
  n <
  m ->
  1 <
  m
Nat.lxor_assoc:
  forall
   a
   b
   c : nat,
  Nat.lxor
   (Nat.lxor
   a
   b)
   c =
  Nat.lxor
   a
   (Nat.lxor
   b
   c)
Nat.sqrt_add_le:
  forall
   a
   b : nat,
  Nat.sqrt
   (a +
   b) <=
  Nat.sqrt
   a +
  Nat.sqrt
   b
Nat.add_shuffle0:
  forall
   n
   m
   p : nat,
  n +
  m +
  p =
  n +
  p +
  m
Nat.add_shuffle3:
  forall
   n
   m
   p : nat,
  n +
  (m +
   p) =
  m +
  (n +
   p)
Nat.eq_dne:
  forall
   n
   m : nat,
  ~
  n <>
  m <->
  n =
  m
Nat.gcd_greatest:
  forall
   a
   b
   c : nat,
  Nat.divide
   c
   a ->
  Nat.divide
   c
   b ->
  Nat.divide
   c
   (Nat.gcd
   a
   b)
Nat.ldiff_le:
  forall
   a
   b : nat,
  Nat.ldiff
   a
   b =
  0 ->
  a <=
  b
Nat.mul_shuffle3:
  forall
   n
   m
   p : nat,
  n *
  (m *
   p) =
  m *
  (n *
   p)
Nat.max_r_iff:
  forall
   n
   m : nat,
  Nat.max
   n
   m =
  m <->
  n <=
  m
PeanoNat.Nat.div_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   Nat.div
   Nat.div
Nat.div_0_l:
  forall
   a : nat,
  a <>
  0 ->
  0 /
  a =
  0
PeanoNat.Nat.add_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   add
   add
Nat.mul_nonneg_nonneg:
  forall
   n
   m : nat,
  0 <=
  n ->
  0 <=
  m ->
  0 <=
  n *
  m
Nat.lt_sub_lt_add_r:
  forall
   n
   m
   p : nat,
  n -
  p <
  m ->
  n <
  m +
  p
Nat.pow_gt_lin_r:
  forall
   a
   b : nat,
  1 <
  a ->
  b <
  a
  ^ b
PeanoNat.Nat.mul_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   mul
   mul
Nat.clearbit_eq:
  forall
   a
   n : nat,
  Nat.testbit
   (Nat.clearbit
   a
   n)
   n =
  false
Nat.lor_ldiff_and:
  forall
   a
   b : nat,
  Nat.lor
   (Nat.ldiff
   a
   b)
   (Nat.land
   a
   b) =
  a
Nat.lt_trichotomy:
  forall
   n
   m : nat,
  n <
  m \/
  n =
  m \/
  m <
  n
Nat.max_l_iff:
  forall
   n
   m : nat,
  Nat.max
   n
   m =
  n <->
  m <=
  n
Nat.succ_min_distr:
  forall
   n
   m : nat,
  S
   (Nat.min
   n
   m) =
  Nat.min
   (S
   n)
   (S
   m)
Nat.ltb_spec:
  forall
   x
   y : nat,
  BoolSpec
   (x <
   y)
   (y <=
   x)
   (x <?
   y)
Nat.le_pred_le_succ:
  forall
   n
   m : nat,
  Nat.pred
   n <=
  m <->
  n <=
  S m
Nat.divide_gcd_iff':
  forall
   n
   m : nat,
  Nat.divide
   n
   m <->
  Nat.gcd
   n
   m =
  n
Nat.add_nonneg_nonneg:
  forall
   n
   m : nat,
  0 <=
  n ->
  0 <=
  m ->
  0 <=
  n +
  m
PeanoNat.Nat.sub_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   sub
   sub
Nat.mul_pos_neg:
  forall
   n
   m : nat,
  0 <
  n ->
  m <
  0 ->
  n *
  m <
  0
Nat.mul_neg_neg:
  forall
   n
   m : nat,
  n <
  0 ->
  m <
  0 ->
  0 <
  n *
  m
Nat.setbit_eq:
  forall
   a
   n : nat,
  Nat.testbit
   (Nat.setbit
   a
   n)
   n =
  true
Nat.mod_0_l:
  forall
   a : nat,
  a <>
  0 ->
  0
  mod a =
  0
Nat.lt_1_r:
  forall
   n : nat,
  n <
  1 <->
  n =
  0
Nat.divide_lcm_iff:
  forall
   n
   m : nat,
  Nat.divide
   n
   m <->
  Nat.lcm
   n
   m =
  m
Nat.lt_sub_lt_add_l:
  forall
   n
   m
   p : nat,
  n -
  m <
  p ->
  n <
  m +
  p
PeanoNat.Nat.mod_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   Nat.modulo
   Nat.modulo
Nat.compare_eq:
  forall
   x
   y : nat,
  (x
   ?= y) =
  Eq ->
  x =
  y
Nat.le_add_le_sub_r:
  forall
   n
   m
   p : nat,
  n +
  p <=
  m ->
  n <=
  m -
  p
Nat.mul_pos_pos:
  forall
   n
   m : nat,
  0 <
  n ->
  0 <
  m ->
  0 <
  n *
  m
Nat.succ_max_distr:
  forall
   n
   m : nat,
  S
   (Nat.max
   n
   m) =
  Nat.max
   (S
   n)
   (S
   m)
Nat.lt_total:
  forall
   n
   m : nat,
  n <
  m \/
  n =
  m \/
  m <
  n
Nat.add_pos_pos:
  forall
   n
   m : nat,
  0 <
  n ->
  0 <
  m ->
  0 <
  n +
  m
Nat.min_l_iff:
  forall
   n
   m : nat,
  Nat.min
   n
   m =
  n <->
  n <=
  m
Nat.mul_neg_pos:
  forall
   n
   m : nat,
  n <
  0 ->
  0 <
  m ->
  n *
  m <
  0
Nat.lt_succ_pred:
  forall
   z
   n : nat,
  z <
  n ->
  S
   (Nat.pred
   n) =
  n
Nat.leb_spec:
  forall
   x
   y : nat,
  BoolSpec
   (x <=
   y)
   (y <
   x)
   (x <=?
   y)
Nat.le_add_le_sub_l:
  forall
   n
   m
   p : nat,
  n +
  p <=
  m ->
  p <=
  m -
  n
Nat.pow_0_l:
  forall
   a : nat,
  a <>
  0 ->
  0
  ^ a =
  0
Nat.min_r_iff:
  forall
   n
   m : nat,
  Nat.min
   n
   m =
  m <->
  m <=
  n
Nat.nlt_succ_r:
  forall
   n
   m : nat,
  ~
  m <
  S n <->
  n <
  m
PeanoNat.Nat.pow_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   Nat.pow
   Nat.pow
Nat.neq_0_lt_0:
  forall
   n : nat,
  n <>
  0 <->
  0 <
  n
Nat.mod_same:
  forall
   a : nat,
  a <>
  0 ->
  a
  mod a =
  0
Nat.divide_pos_le:
  forall
   n
   m : nat,
  0 <
  m ->
  Nat.divide
   n
   m ->
  n <=
  m
Nat.lt_succ_lt_pred:
  forall
   n
   m : nat,
  S n <
  m <->
  n <
  Nat.pred
   m
Nat.add_lt_mono_l:
  forall
   n
   m
   p : nat,
  n <
  m <->
  p +
  n <
  p +
  m
Nat.lt_pred_l:
  forall
   n : nat,
  n <>
  0 ->
  Nat.pred
   n <
  n
Nat.even_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.even
Nat.gt_wf:
  forall
   z : nat,
  well_founded
   (fun
   n
   m : nat
   =>
   m <
   n <=
   z)
Nat.div2_double:
  forall
   n : nat,
  Nat.div2
   (2 *
   n) =
  n
Nat.lxor_eq_0_iff:
  forall
   a
   a' : nat,
  Nat.lxor
   a
   a' =
  0 <->
  a =
  a'
Nat.b2n_proper:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.b2n
Nat.sub_succ_r:
  forall
   n
   m : nat,
  n -
  S m =
  Nat.pred
   (n -
   m)
Nat.max_dec:
  forall
   n
   m : nat,
  {Nat.max
   n
   m =
   n}
  +
  {Nat.max
   n
   m =
   m}
Nat.sqrt_up_succ_le:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt_up
   (S
   a) <=
  S
   (Nat.sqrt_up
   a)
PeanoNat.Nat.lt_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff)
   lt
   lt
Nat.compare_succ:
  forall
   n
   m : nat,
  (S
   n
   ?= 
   S
   m) =
  (n
   ?= m)
Nat.lt_wf:
  forall
   z : nat,
  well_founded
   (fun
   n
   m : nat
   =>
   z <=
   n <
   m)
Nat.min_dec:
  forall
   n
   m : nat,
  {Nat.min
   n
   m =
   n}
  +
  {Nat.min
   n
   m =
   m}
Nat.sqrt_lt_square:
  forall
   a
   b : nat,
  a <
  b *
  b <->
  Nat.sqrt
   a <
  b
Nat.sqrt_le_square:
  forall
   a
   b : nat,
  b *
  b <=
  a <->
  b <=
  Nat.sqrt
   a
Nat.lt_1_l':
  forall
   n
   m
   p : nat,
  n <
  m ->
  m <
  p ->
  1 <
  p
Nat.add_lt_mono_r:
  forall
   n
   m
   p : nat,
  n <
  m <->
  n +
  p <
  m +
  p
Nat.odd_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   Nat.odd
Nat.bits_inj_iff:
  forall
   a
   b : nat,
  Nat.eqf
   (Nat.testbit
   a)
   (Nat.testbit
   b) <->
  a =
  b
Nat.add_le_mono_r:
  forall
   n
   m
   p : nat,
  n <=
  m <->
  n +
  p <=
  m +
  p
Nat.max_min_disassoc:
  forall
   n
   m
   p : nat,
  Nat.min
   n
   (Nat.max
   m
   p) <=
  Nat.max
   (Nat.min
   n
   m)
   p
Nat.rbase:
  forall
   (A : 
   nat ->
   Prop)
   (z : nat),
  (fun
   n : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n ->
   A
   m)
   z
Nat.succ_pred_pos:
  forall
   n : nat,
  0 <
  n ->
  S
   (Nat.pred
   n) =
  n
Nat.div2_div:
  forall
   a : nat,
  Nat.div2
   a =
  a /
  2
Nat.shiftl_eq_0_iff:
  forall
   a
   n : nat,
  Nat.shiftl
   a
   n =
  0 <->
  a =
  0
Nat.log2_up_eqn0:
  forall
   a : nat,
  a <=
  1 ->
  Nat.log2_up
   a =
  0
Nat.double_twice:
  forall
   n : nat,
  Nat.double
   n =
  2 *
  n
Nat.log2_shiftr:
  forall
   a
   n : nat,
  Nat.log2
   (Nat.shiftr
   a
   n) =
  Nat.log2
   a -
  n
Nat.gcd_bezout:
  forall
   n
   m : nat,
  Nat.Bezout
   n
   m
   (Nat.gcd
   n
   m) \/
  Nat.Bezout
   m
   n
   (Nat.gcd
   n
   m)
Nat.add_le_mono_l:
  forall
   n
   m
   p : nat,
  n <=
  m <->
  p +
  n <=
  p +
  m
Nat.lnot_lxor_r:
  forall
   a
   b
   n : nat,
  Nat.lnot
   (Nat.lxor
   a
   b)
   n =
  Nat.lxor
   a
   (Nat.lnot
   b
   n)
Nat.shiftl_shiftl:
  forall
   a
   n
   m : nat,
  Nat.shiftl
   (Nat.shiftl
   a
   n)
   m =
  Nat.shiftl
   a
   (n +
   m)
Nat.odd_spec:
  forall
   n : nat,
  Nat.odd
   n =
  true <->
  Nat.Odd
   n
Nat.lnot_lxor_l:
  forall
   a
   b
   n : nat,
  Nat.lnot
   (Nat.lxor
   a
   b)
   n =
  Nat.lxor
   (Nat.lnot
   a
   n)
   b
Nat.testbit_odd:
  forall
   a
   n : nat,
  Nat.testbit
   a
   n =
  Nat.odd
   (Nat.shiftr
   a
   n)
Nat.orb_even_odd:
  forall
   n : nat,
  Nat.even
   n
  || 
  Nat.odd
   n =
  true
Nat.pow_2_r:
  forall
   a : nat,
  a
  ^ 2 =
  a *
  a
Nat.even_spec:
  forall
   n : nat,
  Nat.even
   n =
  true <->
  Nat.Even
   n
Nat.mul_pred_r:
  forall
   n
   m : nat,
  n *
  Nat.pred
   m =
  n *
  m -
  n
Nat.ltb_antisym:
  forall
   x
   y : nat,
  (y <?
   x) =
  negb
   (x <=?
   y)
Nat.pow_succ_r':
  forall
   a
   b : nat,
  a
  ^ 
  S b =
  a *
  a
  ^ b
Nat.pow_mul_r:
  forall
   a
   b
   c : nat,
  a
  ^ 
  (b *
   c) =
  (a
   ^ b)
  ^ c
Nat.sqrt_up_square:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt_up
   (a *
   a) =
  a
Nat.add_sub_eq_l:
  forall
   n
   m
   p : nat,
  m +
  p =
  n ->
  n -
  m =
  p
Nat.ldiff_ldiff_l:
  forall
   a
   b
   c : nat,
  Nat.ldiff
   (Nat.ldiff
   a
   b)
   c =
  Nat.ldiff
   a
   (Nat.lor
   b
   c)
Nat.leb_antisym:
  forall
   x
   y : nat,
  (y <=?
   x) =
  negb
   (x <?
   y)
Nat.sub_add_distr:
  forall
   n
   m
   p : nat,
  n -
  (m +
   p) =
  n -
  m -
  p
Nat.log2_lxor:
  forall
   a
   b : nat,
  Nat.log2
   (Nat.lxor
   a
   b) <=
  Nat.max
   (Nat.log2
   a)
   (Nat.log2
   b)
Nat.shiftr_shiftr:
  forall
   a
   n
   m : nat,
  Nat.shiftr
   (Nat.shiftr
   a
   n)
   m =
  Nat.shiftr
   a
   (n +
   m)
Nat.lor_lnot_diag:
  forall
   a
   n : nat,
  Nat.lor
   a
   (Nat.lnot
   a
   n) =
  Nat.lor
   a
   (Nat.ones
   n)
Nat.mul_succ_l:
  forall
   n
   m : nat,
  S n *
  m =
  n *
  m +
  m
Nat.add_sub_eq_r:
  forall
   n
   m
   p : nat,
  m +
  p =
  n ->
  n -
  p =
  m
Nat.lxor_lnot_lnot:
  forall
   a
   b
   n : nat,
  Nat.lxor
   (Nat.lnot
   a
   n)
   (Nat.lnot
   b
   n) =
  Nat.lxor
   a
   b
Nat.mul_succ_r:
  forall
   n
   m : nat,
  n *
  S m =
  n *
  m +
  n
Nat.sub_add:
  forall
   n
   m : nat,
  n <=
  m ->
  m -
  n +
  n =
  m
Nat.log2_land:
  forall
   a
   b : nat,
  Nat.log2
   (Nat.land
   a
   b) <=
  Nat.min
   (Nat.log2
   a)
   (Nat.log2
   b)
Nat.add_cancel_l:
  forall
   n
   m
   p : nat,
  p +
  n =
  p +
  m <->
  n =
  m
Nat.add_cancel_r:
  forall
   n
   m
   p : nat,
  n +
  p =
  m +
  p <->
  n =
  m
Nat.min_le:
  forall
   n
   m
   p : nat,
  Nat.min
   n
   m <=
  p ->
  n <=
  p \/
  m <=
  p
Nat.log2_lor:
  forall
   a
   b : nat,
  Nat.log2
   (Nat.lor
   a
   b) =
  Nat.max
   (Nat.log2
   a)
   (Nat.log2
   b)
Nat.square_le_simpl_nonneg:
  forall
   n
   m : nat,
  0 <=
  m ->
  n *
  n <=
  m *
  m ->
  n <=
  m
Nat.tail_addmul_spec:
  forall
   r
   n
   m : nat,
  Nat.tail_addmul
   r
   n
   m =
  r +
  n *
  m
Nat.div2_succ_double:
  forall
   n : nat,
  Nat.div2
   (S
   (2 *
   n)) =
  n
PeanoNat.Nat.testbit_wd_obligation_1:
  Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq)
   Nat.testbit
   Nat.testbit
Nat.add_pos_nonneg:
  forall
   n
   m : nat,
  0 <
  n ->
  0 <=
  m ->
  0 <
  n +
  m
Nat.lbase:
  forall
   (A : 
   nat ->
   Prop)
   (z : nat),
  (fun
   n : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n <=
   m ->
   A
   m)
   (S
   z)
Nat.square_le_mono_nonneg:
  forall
   n
   m : nat,
  0 <=
  n ->
  n <=
  m ->
  n *
  n <=
  m *
  m
Nat.max_le:
  forall
   n
   m
   p : nat,
  p <=
  Nat.max
   n
   m ->
  p <=
  n \/
  p <=
  m
Nat.bits_inj_0:
  forall
   a : nat,
  (forall
   n : nat,
   Nat.testbit
   a
   n =
   false) ->
  a =
  0
Nat.sub_lt:
  forall
   n
   m : nat,
  m <=
  n ->
  0 <
  m ->
  n -
  m <
  n
Nat.add_nonneg_pos:
  forall
   n
   m : nat,
  0 <=
  n ->
  0 <
  m ->
  0 <
  n +
  m
Nat.sub_0_le:
  forall
   n
   m : nat,
  n -
  m =
  0 <->
  n <=
  m
Nat.shiftr_eq_0:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.shiftr
   a
   n =
  0
Nat.mul_pos_cancel_l:
  forall
   n
   m : nat,
  0 <
  n ->
  0 <
  n *
  m <->
  0 <
  m
Nat.lt_add_lt_sub_l:
  forall
   n
   m
   p : nat,
  n +
  p <
  m <->
  p <
  m -
  n
Nat.succ_pred:
  forall
   n : nat,
  n <>
  0 ->
  S
   (Nat.pred
   n) =
  n
Nat.le_sub_le_add_l:
  forall
   n
   m
   p : nat,
  n -
  m <=
  p <->
  n <=
  m +
  p
Nat.add_pos_cases:
  forall
   n
   m : nat,
  0 <
  n +
  m ->
  0 <
  n \/
  0 <
  m
Nat.mul_lt_mono:
  forall
   n
   m
   p
   q : nat,
  n <
  m ->
  p <
  q ->
  n *
  p <
  m *
  q
Nat.pow_nonzero:
  forall
   a
   b : nat,
  a <>
  0 ->
  a
  ^ b <>
  0
Nat.mul_pos_cancel_r:
  forall
   n
   m : nat,
  0 <
  m ->
  0 <
  n *
  m <->
  0 <
  n
Nat.b2n_div2:
  forall
   a0 : bool,
  Nat.b2n
   a0 /
  2 =
  0
Nat.eqb_eq:
  forall
   n
   m : nat,
  (n =?
   m) =
  true <->
  n =
  m
Nat.lt_add_lt_sub_r:
  forall
   n
   m
   p : nat,
  n +
  p <
  m <->
  n <
  m -
  p
Nat.add_nonpos_cases:
  forall
   n
   m : nat,
  n +
  m <=
  0 ->
  n <=
  0 \/
  m <=
  0
Nat.mul_le_mono:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p <=
  q ->
  n *
  p <=
  m *
  q
Nat.sub_gt:
  forall
   n
   m : nat,
  m <
  n ->
  n -
  m <>
  0
Nat.add_lt_mono:
  forall
   n
   m
   p
   q : nat,
  n <
  m ->
  p <
  q ->
  n +
  p <
  m +
  q
Nat.max_le_compat:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p <=
  q ->
  Nat.max
   n
   p <=
  Nat.max
   m
   q
Nat.le_sub_le_add_r:
  forall
   n
   m
   p : nat,
  n -
  p <=
  m <->
  n <=
  m +
  p
Nat.mod_upper_bound:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  mod b <
  b
Nat.add_nonneg_cases:
  forall
   n
   m : nat,
  0 <=
  n +
  m ->
  0 <=
  n \/
  0 <=
  m
Nat.add_le_mono:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p <=
  q ->
  n +
  p <=
  m +
  q
Nat.shiftl_1_l:
  forall
   n : nat,
  Nat.shiftl
   1
   n =
  2
  ^ n
Nat.compare_eq_iff:
  forall
   n
   m : nat,
  (n
   ?= m) =
  Eq <->
  n =
  m
Nat.min_le_compat:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p <=
  q ->
  Nat.min
   n
   p <=
  Nat.min
   m
   q
Nat.mod_le:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  mod b <=
  a
Nat.le_le_add_le:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p +
  m <=
  q +
  n ->
  p <=
  q
Nat.add_neg_cases:
  forall
   n
   m : nat,
  n +
  m <
  0 ->
  n <
  0 \/
  m <
  0
Nat.div_1_l:
  forall
   a : nat,
  1 <
  a ->
  1 /
  a =
  0
Nat.gcd_sub_diag_r:
  forall
   n
   m : nat,
  n <=
  m ->
  Nat.gcd
   n
   (m -
   n) =
  Nat.gcd
   n
   m
Nat.add_min_distr_l:
  forall
   n
   m
   p : nat,
  Nat.min
   (p +
   n)
   (p +
   m) =
  p +
  Nat.min
   n
   m
Nat.mul_le_mono_nonneg_r:
  forall
   n
   m
   p : nat,
  0 <=
  p ->
  n <=
  m ->
  n *
  p <=
  m *
  p
Nat.gcd_mul_mono_l:
  forall
   n
   m
   p : nat,
  Nat.gcd
   (p *
   n)
   (p *
   m) =
  p *
  Nat.gcd
   n
   m
Nat.mul_max_distr_r:
  forall
   n
   m
   p : nat,
  Nat.max
   (n *
   p)
   (m *
   p) =
  Nat.max
   n
   m *
  p
Nat.ldiff_ones_r:
  forall
   a
   n : nat,
  Nat.ldiff
   a
   (Nat.ones
   n) =
  Nat.shiftl
   (Nat.shiftr
   a
   n)
   n
Nat.sub_min_distr_r:
  forall
   n
   m
   p : nat,
  Nat.min
   (n -
   p)
   (m -
   p) =
  Nat.min
   n
   m -
  p
Nat.min_max_distr:
  forall
   n
   m
   p : nat,
  Nat.min
   n
   (Nat.max
   m
   p) =
  Nat.max
   (Nat.min
   n
   m)
   (Nat.min
   n
   p)
Nat.add_max_distr_r:
  forall
   n
   m
   p : nat,
  Nat.max
   (n +
   p)
   (m +
   p) =
  Nat.max
   n
   m +
  p
Nat.add_max_distr_l:
  forall
   n
   m
   p : nat,
  Nat.max
   (p +
   n)
   (p +
   m) =
  p +
  Nat.max
   n
   m
Nat.lcm_mul_mono_l:
  forall
   n
   m
   p : nat,
  Nat.lcm
   (p *
   n)
   (p *
   m) =
  p *
  Nat.lcm
   n
   m
Nat.shiftr_lor:
  forall
   a
   b
   n : nat,
  Nat.shiftr
   (Nat.lor
   a
   b)
   n =
  Nat.lor
   (Nat.shiftr
   a
   n)
   (Nat.shiftr
   b
   n)
Nat.land_lnot_diag:
  forall
   a
   n : nat,
  Nat.land
   a
   (Nat.lnot
   a
   n) =
  Nat.ldiff
   a
   (Nat.ones
   n)
Nat.mul_max_distr_l:
  forall
   n
   m
   p : nat,
  Nat.max
   (p *
   n)
   (p *
   m) =
  p *
  Nat.max
   n
   m
Nat.pow_mul_l:
  forall
   a
   b
   c : nat,
  (a *
   b)
  ^ c =
  a
  ^ c *
  b
  ^ c
Nat.lor_land_distr_r:
  forall
   a
   b
   c : nat,
  Nat.lor
   a
   (Nat.land
   b
   c) =
  Nat.land
   (Nat.lor
   a
   b)
   (Nat.lor
   a
   c)
Nat.shiftr_lxor:
  forall
   a
   b
   n : nat,
  Nat.shiftr
   (Nat.lxor
   a
   b)
   n =
  Nat.lxor
   (Nat.shiftr
   a
   n)
   (Nat.shiftr
   b
   n)
Nat.compare_spec:
  forall
   x
   y : nat,
  CompareSpec
   (x =
   y)
   (x <
   y)
   (y <
   x)
   (x
   ?= y)
Nat.mul_min_distr_r:
  forall
   n
   m
   p : nat,
  Nat.min
   (n *
   p)
   (m *
   p) =
  Nat.min
   n
   m *
  p
Nat.mul_add_distr_l:
  forall
   n
   m
   p : nat,
  n *
  (m +
   p) =
  n *
  m +
  n *
  p
Nat.lor_land_distr_l:
  forall
   a
   b
   c : nat,
  Nat.lor
   (Nat.land
   a
   b)
   c =
  Nat.land
   (Nat.lor
   a
   c)
   (Nat.lor
   b
   c)
Nat.mul_le_mono_nonpos_l:
  forall
   n
   m
   p : nat,
  p <=
  0 ->
  n <=
  m ->
  p *
  m <=
  p *
  n
Nat.add_min_distr_r:
  forall
   n
   m
   p : nat,
  Nat.min
   (n +
   p)
   (m +
   p) =
  Nat.min
   n
   m +
  p
Nat.shiftr_land:
  forall
   a
   b
   n : nat,
  Nat.shiftr
   (Nat.land
   a
   b)
   n =
  Nat.land
   (Nat.shiftr
   a
   n)
   (Nat.shiftr
   b
   n)
Nat.gcd_mul_diag_l:
  forall
   n
   m : nat,
  0 <=
  n ->
  Nat.gcd
   n
   (n *
   m) =
  n
Nat.mul_sub_distr_r:
  forall
   n
   m
   p : nat,
  (n -
   m) *
  p =
  n *
  p -
  m *
  p
Nat.gcd_mul_mono_r:
  forall
   n
   m
   p : nat,
  Nat.gcd
   (n *
   p)
   (m *
   p) =
  Nat.gcd
   n
   m *
  p
Nat.lcm_mul_mono_r:
  forall
   n
   m
   p : nat,
  Nat.lcm
   (n *
   p)
   (m *
   p) =
  Nat.lcm
   n
   m *
  p
Nat.mul_add_distr_r:
  forall
   n
   m
   p : nat,
  (n +
   m) *
  p =
  n *
  p +
  m *
  p
Nat.mul_le_mono_nonpos_r:
  forall
   n
   m
   p : nat,
  p <=
  0 ->
  n <=
  m ->
  m *
  p <=
  n *
  p
Nat.testbit_neg_r:
  forall
   a
   n : nat,
  n <
  0 ->
  Nat.testbit
   a
   n =
  false
Nat.mul_min_distr_l:
  forall
   n
   m
   p : nat,
  Nat.min
   (p *
   n)
   (p *
   m) =
  p *
  Nat.min
   n
   m
Nat.sub_max_distr_r:
  forall
   n
   m
   p : nat,
  Nat.max
   (n -
   p)
   (m -
   p) =
  Nat.max
   n
   m -
  p
Nat.land_lor_distr_r:
  forall
   a
   b
   c : nat,
  Nat.land
   a
   (Nat.lor
   b
   c) =
  Nat.lor
   (Nat.land
   a
   b)
   (Nat.land
   a
   c)
Nat.div_lt:
  forall
   a
   b : nat,
  0 <
  a ->
  1 <
  b ->
  a /
  b <
  a
Nat.shiftr_ldiff:
  forall
   a
   b
   n : nat,
  Nat.shiftr
   (Nat.ldiff
   a
   b)
   n =
  Nat.ldiff
   (Nat.shiftr
   a
   n)
   (Nat.shiftr
   b
   n)
Nat.gcd_add_mult_diag_r:
  forall
   n
   m
   p : nat,
  Nat.gcd
   n
   (m +
   p *
   n) =
  Nat.gcd
   n
   m
Nat.log2_null:
  forall
   a : nat,
  Nat.log2
   a =
  0 <->
  a <=
  1
Nat.shiftl_lxor:
  forall
   a
   b
   n : nat,
  Nat.shiftl
   (Nat.lxor
   a
   b)
   n =
  Nat.lxor
   (Nat.shiftl
   a
   n)
   (Nat.shiftl
   b
   n)
Nat.log2_up_null:
  forall
   a : nat,
  Nat.log2_up
   a =
  0 <->
  a <=
  1
Nat.shiftl_lor:
  forall
   a
   b
   n : nat,
  Nat.shiftl
   (Nat.lor
   a
   b)
   n =
  Nat.lor
   (Nat.shiftl
   a
   n)
   (Nat.shiftl
   b
   n)
Nat.odd_add_even:
  forall
   n
   m : nat,
  Nat.Even
   m ->
  Nat.odd
   (n +
   m) =
  Nat.odd
   n
Nat.land_lor_distr_l:
  forall
   a
   b
   c : nat,
  Nat.land
   (Nat.lor
   a
   b)
   c =
  Nat.lor
   (Nat.land
   a
   c)
   (Nat.land
   b
   c)
Nat.mul_sub_distr_l:
  forall
   n
   m
   p : nat,
  p *
  (n -
   m) =
  p *
  n -
  p *
  m
Nat.shiftl_ldiff:
  forall
   a
   b
   n : nat,
  Nat.shiftl
   (Nat.ldiff
   a
   b)
   n =
  Nat.ldiff
   (Nat.shiftl
   a
   n)
   (Nat.shiftl
   b
   n)
Nat.even_add_even:
  forall
   n
   m : nat,
  Nat.Even
   m ->
  Nat.even
   (n +
   m) =
  Nat.even
   n
Nat.shiftl_land:
  forall
   a
   b
   n : nat,
  Nat.shiftl
   (Nat.land
   a
   b)
   n =
  Nat.land
   (Nat.shiftl
   a
   n)
   (Nat.shiftl
   b
   n)
Nat.max_min_distr:
  forall
   n
   m
   p : nat,
  Nat.max
   n
   (Nat.min
   m
   p) =
  Nat.min
   (Nat.max
   n
   m)
   (Nat.max
   n
   p)
Nat.mul_le_mono_nonneg_l:
  forall
   n
   m
   p : nat,
  0 <=
  p ->
  n <=
  m ->
  p *
  n <=
  p *
  m
Nat.div_same:
  forall
   a : nat,
  a <>
  0 ->
  a /
  a =
  1
Nat.ones_equiv:
  forall
   n : nat,
  Nat.ones
   n =
  Nat.pred
   (2
   ^ n)
Nat.mod_1_l:
  forall
   a : nat,
  1 <
  a ->
  1
  mod a =
  1
Nat.even_mul:
  forall
   n
   m : nat,
  Nat.even
   (n *
   m) =
  Nat.even
   n
  || 
  Nat.even
   m
Nat.zero_or_succ:
  forall
   n : nat,
  n =
  0 \/
  (exists
   m : nat,
   n =
   S
   m)
Nat.sqrt_mul_above:
  forall
   a
   b : nat,
  Nat.sqrt
   (a *
   b) <
  S
   (Nat.sqrt
   a) *
  S
   (Nat.sqrt
   b)
Nat.square_lt_mono_nonneg:
  forall
   n
   m : nat,
  0 <=
  n ->
  n <
  m ->
  n *
  n <
  m *
  m
Nat.sub_succ_l:
  forall
   n
   m : nat,
  n <=
  m ->
  S m -
  n =
  S
   (m -
   n)
Nat.leb_gt:
  forall
   x
   y : nat,
  (x <=?
   y) =
  false <->
  y <
  x
Nat.land_ones_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.land
   a
   (Nat.ones
   n) =
  a
Nat.sub_nocarry_ldiff:
  forall
   a
   b : nat,
  Nat.ldiff
   b
   a =
  0 ->
  a -
  b =
  Nat.ldiff
   a
   b
Nat.even_add:
  forall
   n
   m : nat,
  Nat.even
   (n +
   m) =
  Bool.eqb
   (Nat.even
   n)
   (Nat.even
   m)
Nat.square_lt_simpl_nonneg:
  forall
   n
   m : nat,
  0 <=
  m ->
  n *
  n <
  m *
  m ->
  n <
  m
Nat.compare_gt_iff:
  forall
   x
   y : nat,
  (x
   ?= y) =
  Gt <->
  y <
  x
Nat.lt_eq_cases:
  forall
   n
   m : nat,
  n <=
  m <->
  n <
  m \/
  n =
  m
Nat.ltb_lt:
  forall
   n
   m : nat,
  (n <?
   m) =
  true <->
  n <
  m
Nat.leb_le:
  forall
   n
   m : nat,
  (n <=?
   m) =
  true <->
  n <=
  m
Nat.divide_1_r_nonneg:
  forall
   n : nat,
  0 <=
  n ->
  Nat.divide
   n
   1 ->
  n =
  1
Nat.odd_mul:
  forall
   n
   m : nat,
  Nat.odd
   (n *
   m) =
  Nat.odd
   n &&
  Nat.odd
   m
Nat.odd_add:
  forall
   n
   m : nat,
  Nat.odd
   (n +
   m) =
  xorb
   (Nat.odd
   n)
   (Nat.odd
   m)
Nat.le_lteq:
  forall
   n
   m : nat,
  n <=
  m <->
  n <
  m \/
  n =
  m
Nat.ltb_ge:
  forall
   x
   y : nat,
  (x <?
   y) =
  false <->
  y <=
  x
Nat.testbit_eqf:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   Nat.eqf)
   Nat.testbit
Nat.compare_lt_iff:
  forall
   n
   m : nat,
  (n
   ?= m) =
  Lt <->
  n <
  m
Nat.succ_inj_wd_neg:
  forall
   n
   m : nat,
  S n <>
  S m <->
  n <>
  m
Nat.lcm_divide_iff:
  forall
   n
   m
   p : nat,
  Nat.divide
   (Nat.lcm
   n
   m)
   p <->
  Nat.divide
   n
   p /\
  Nat.divide
   m
   p
Nat.add_lt_le_mono:
  forall
   n
   m
   p
   q : nat,
  n <
  m ->
  p <=
  q ->
  n +
  p <
  m +
  q
Nat.min_glb_iff:
  forall
   n
   m
   p : nat,
  p <=
  Nat.min
   n
   m <->
  p <=
  n /\
  p <=
  m
Nat.bits_above_log2:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.testbit
   a
   n =
  false
Nat.lt_le_add_lt:
  forall
   n
   m
   p
   q : nat,
  n <
  m ->
  p +
  m <=
  q +
  n ->
  p <
  q
Nat.bezout_1_gcd:
  forall
   n
   m : nat,
  Nat.Bezout
   n
   m
   1 ->
  Nat.gcd
   n
   m =
  1
Nat.ones_spec_low:
  forall
   n
   m : nat,
  m <
  n ->
  Nat.testbit
   (Nat.ones
   n)
   m =
  true
Nat.lt_1_mul_pos:
  forall
   n
   m : nat,
  1 <
  n ->
  0 <
  m ->
  1 <
  n *
  m
Nat.add_shuffle2:
  forall
   n
   m
   p
   q : nat,
  n +
  m +
  (p +
   q) =
  n +
  q +
  (m +
   p)
Nat.add_shuffle1:
  forall
   n
   m
   p
   q : nat,
  n +
  m +
  (p +
   q) =
  n +
  p +
  (m +
   q)
Nat.gcd_divide_iff:
  forall
   n
   m
   p : nat,
  Nat.divide
   p
   (Nat.gcd
   n
   m) <->
  Nat.divide
   p
   n /\
  Nat.divide
   p
   m
Nat.mul_shuffle2:
  forall
   n
   m
   p
   q : nat,
  n *
  m *
  (p *
   q) =
  n *
  q *
  (m *
   p)
Nat.min_glb_lt_iff:
  forall
   n
   m
   p : nat,
  p <
  Nat.min
   n
   m <->
  p <
  n /\
  p <
  m
Nat.max_lub_lt_iff:
  forall
   n
   m
   p : nat,
  Nat.max
   n
   m <
  p <->
  n <
  p /\
  m <
  p
Nat.min_lt_iff:
  forall
   n
   m
   p : nat,
  Nat.min
   n
   m <
  p <->
  n <
  p \/
  m <
  p
Nat.max_lub_iff:
  forall
   n
   m
   p : nat,
  Nat.max
   n
   m <=
  p <->
  n <=
  p /\
  m <=
  p
Nat.mul_nonneg_cancel_r:
  forall
   n
   m : nat,
  0 <
  m ->
  0 <=
  n *
  m <->
  0 <=
  n
Nat.div_str_pos:
  forall
   a
   b : nat,
  0 <
  b <=
  a ->
  0 <
  a /
  b
Nat.max_le_iff:
  forall
   n
   m
   p : nat,
  p <=
  Nat.max
   n
   m <->
  p <=
  n \/
  p <=
  m
Nat.max_lt_iff:
  forall
   n
   m
   p : nat,
  p <
  Nat.max
   n
   m <->
  p <
  n \/
  p <
  m
Nat.add_le_lt_mono:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p <
  q ->
  n +
  p <
  m +
  q
Nat.bit0_mod:
  forall
   a : nat,
  Nat.b2n
   (Nat.testbit
   a
   0) =
  a
  mod 2
Nat.mul_shuffle1:
  forall
   n
   m
   p
   q : nat,
  n *
  m *
  (p *
   q) =
  n *
  p *
  (m *
   q)
Nat.min_le_iff:
  forall
   n
   m
   p : nat,
  Nat.min
   n
   m <=
  p <->
  n <=
  p \/
  m <=
  p
Nat.ones_spec_high:
  forall
   n
   m : nat,
  n <=
  m ->
  Nat.testbit
   (Nat.ones
   n)
   m =
  false
Nat.le_lt_add_lt:
  forall
   n
   m
   p
   q : nat,
  n <=
  m ->
  p +
  m <
  q +
  n ->
  p <
  q
Nat.mul_nonneg_cancel_l:
  forall
   n
   m : nat,
  0 <
  n ->
  0 <=
  n *
  m <->
  0 <=
  m
Nat.pow2_bits_true:
  forall
   n : nat,
  Nat.testbit
   (2
   ^ n)
   n =
  true
Nat.div_mul:
  forall
   a
   b : nat,
  b <>
  0 ->
  a *
  b /
  b =
  a
Nat.add_le_cases:
  forall
   n
   m
   p
   q : nat,
  n +
  m <=
  p +
  q ->
  n <=
  p \/
  m <=
  q
Nat.shiftr_specif:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.shiftr
   a
   n)
   m =
  Nat.testbit
   a
   (m +
   n)
Nat.mod_mul:
  forall
   a
   b : nat,
  b <>
  0 ->
  (a *
   b)
  mod b =
  0
Nat.lt_gt_cases:
  forall
   n
   m : nat,
  n <>
  m <->
  n <
  m \/
  m <
  n
Nat.sub_min_distr_l:
  forall
   n
   m
   p : nat,
  Nat.min
   (p -
   n)
   (p -
   m) =
  p -
  Nat.max
   n
   m
Nat.lor_ones_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.lor
   a
   (Nat.ones
   n) =
  Nat.ones
   n
Nat.eq_mul_0_l:
  forall
   n
   m : nat,
  n *
  m =
  0 ->
  m <>
  0 ->
  n =
  0
Nat.max_min_modular:
  forall
   n
   m
   p : nat,
  Nat.max
   n
   (Nat.min
   m
   (Nat.max
   n
   p)) =
  Nat.min
   (Nat.max
   n
   m)
   (Nat.max
   n
   p)
Nat.mod_mod:
  forall
   a
   n : nat,
  n <>
  0 ->
  (a
   mod n)
  mod n =
  a
  mod n
Nat.mul_eq_0_r:
  forall
   n
   m : nat,
  n *
  m =
  0 ->
  n <>
  0 ->
  m =
  0
Nat.sub_max_distr_l:
  forall
   n
   m
   p : nat,
  Nat.max
   (p -
   n)
   (p -
   m) =
  p -
  Nat.min
   n
   m
Nat.min_case_strong:
  forall
   (n
   m : nat)
   (P : 
   nat ->
   Type),
  (n <=
   m ->
   P
   n) ->
  (m <=
   n ->
   P
   m) ->
  P
   (Nat.min
   n
   m)
Nat.testbit_even_0:
  forall
   a : nat,
  Nat.testbit
   (2 *
   a)
   0 =
  false
Nat.pow_eq_0:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  ^ b =
  0 ->
  a =
  0
Nat.min_max_modular:
  forall
   n
   m
   p : nat,
  Nat.min
   n
   (Nat.max
   m
   (Nat.min
   n
   p)) =
  Nat.max
   (Nat.min
   n
   m)
   (Nat.min
   n
   p)
Nat.lt_0_mul':
  forall
   n
   m : nat,
  0 <
  n *
  m <->
  0 <
  n /\
  0 <
  m
Nat.mul_eq_0_l:
  forall
   n
   m : nat,
  n *
  m =
  0 ->
  m <>
  0 ->
  n =
  0
Nat.eq_mul_0_r:
  forall
   n
   m : nat,
  n *
  m =
  0 ->
  n <>
  0 ->
  m =
  0
Nat.max_case_strong:
  forall
   (n
   m : nat)
   (P : 
   nat ->
   Type),
  (m <=
   n ->
   P
   n) ->
  (n <=
   m ->
   P
   m) ->
  P
   (Nat.max
   n
   m)
Nat.add_lt_cases:
  forall
   n
   m
   p
   q : nat,
  n +
  m <
  p +
  q ->
  n <
  p \/
  m <
  q
Nat.pow_add_r:
  forall
   a
   b
   c : nat,
  a
  ^ 
  (b +
   c) =
  a
  ^ b *
  a
  ^ c
Nat.shiftl_spec_alt:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.shiftl
   a
   n)
   (m +
   n) =
  Nat.testbit
   a
   m
Nat.shiftr_spec':
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.shiftr
   a
   n)
   m =
  Nat.testbit
   a
   (m +
   n)
Nat.lor_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.lor
Nat.land_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.land
Nat.mul_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   mul
Nat.lnot_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.lnot
Nat.gcd_div_swap:
  forall
   a
   b : nat,
  a /
  Nat.gcd
   a
   b *
  b =
  a *
  (b /
   Nat.gcd
   a
   b)
Nat.zero_one:
  forall
   n : nat,
  n =
  0 \/
  n =
  1 \/
  1 <
  n
Nat.clearbit_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.clearbit
Nat.add_nocarry_lxor:
  forall
   a
   b : nat,
  Nat.land
   a
   b =
  0 ->
  a +
  b =
  Nat.lxor
   a
   b
Nat.mod_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.modulo
Nat.eqb_neq:
  forall
   x
   y : nat,
  (x =?
   y) =
  false <->
  x <>
  y
Nat.sub_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   sub
Nat.setbit_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.setbit
Nat.pow_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.pow
Nat.mul_lt_mono_pos_r:
  forall
   p
   n
   m : nat,
  0 <
  p ->
  n <
  m <->
  n *
  p <
  m *
  p
Nat.mul_lt_mono_pos_l:
  forall
   p
   n
   m : nat,
  0 <
  p ->
  n <
  m <->
  p *
  n <
  p *
  m
Nat.gcd_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.gcd
Nat.lcm_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.lcm
Nat.shiftr_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.shiftr
Nat.add_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   add
Nat.sqrt_up_succ_square:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt_up
   (S
   (a *
   a)) =
  S a
Nat.mul_lt_mono_neg_l:
  forall
   p
   n
   m : nat,
  p <
  0 ->
  n <
  m <->
  p *
  m <
  p *
  n
Nat.min_compat:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.min
Nat.lxor_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.lxor
Nat.mul_lt_mono_neg_r:
  forall
   p
   n
   m : nat,
  p <
  0 ->
  n <
  m <->
  m *
  p <
  n *
  p
Nat.shiftl_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.shiftl
Nat.ldiff_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.ldiff
Nat.div_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.div
Nat.lxor_lor:
  forall
   a
   b : nat,
  Nat.land
   a
   b =
  0 ->
  Nat.lxor
   a
   b =
  Nat.lor
   a
   b
Nat.log2_up_pow2:
  forall
   a : nat,
  0 <=
  a ->
  Nat.log2_up
   (2
   ^ a) =
  a
Nat.ldiff_ones_r_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.ldiff
   a
   (Nat.ones
   n) =
  0
Nat.max_compat:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.max
Nat.log2_pow2:
  forall
   a : nat,
  0 <=
  a ->
  Nat.log2
   (2
   ^ a) =
  a
Nat.log2_up_succ_or:
  forall
   a : nat,
  Nat.log2_up
   (S
   a) =
  S
   (Nat.log2_up
   a) \/
  Nat.log2_up
   (S
   a) =
  Nat.log2_up
   a
Nat.clearbit_spec':
  forall
   a
   n : nat,
  Nat.clearbit
   a
   n =
  Nat.ldiff
   a
   (2
   ^ n)
Nat.le_succ_r:
  forall
   n
   m : nat,
  n <=
  S m <->
  n <=
  m \/
  n =
  S m
Nat.add_sub_swap:
  forall
   n
   m
   p : nat,
  p <=
  n ->
  n +
  m -
  p =
  n -
  p +
  m
Nat.lt_alt_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   Nat.lt_alt
Nat.le_alt_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   Nat.le_alt
Nat.lt_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   lt
Nat.mul_div_le:
  forall
   a
   b : nat,
  b <>
  0 ->
  b *
  (a /
   b) <=
  a
Nat.pow_lt_mono_r:
  forall
   a
   b
   c : nat,
  1 <
  a ->
  b <
  c ->
  a
  ^ b <
  a
  ^ c
Nat.land_lnot_diag_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.land
   a
   (Nat.lnot
   a
   n) =
  0
Nat.sqrt_succ_or:
  forall
   a : nat,
  Nat.sqrt
   (S
   a) =
  S
   (Nat.sqrt
   a) \/
  Nat.sqrt
   (S
   a) =
  Nat.sqrt
   a
Nat.add_sub_assoc:
  forall
   n
   m
   p : nat,
  p <=
  m ->
  n +
  (m -
   p) =
  n +
  m -
  p
Nat.lnot_spec_high:
  forall
   a
   n
   m : nat,
  n <=
  m ->
  Nat.testbit
   (Nat.lnot
   a
   n)
   m =
  Nat.testbit
   a
   m
Nat.le_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   le
Nat.divide_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   Nat.divide
Nat.shiftl_mul_pow2:
  forall
   a
   n : nat,
  Nat.shiftl
   a
   n =
  a *
  2
  ^ n
Nat.shiftl_spec_low:
  forall
   a
   n
   m : nat,
  m <
  n ->
  Nat.testbit
   (Nat.shiftl
   a
   n)
   m =
  false
Nat.Proper_instance_0:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   le
Nat.log2_succ_or:
  forall
   a : nat,
  Nat.log2
   (S
   a) =
  S
   (Nat.log2
   a) \/
  Nat.log2
   (S
   a) =
  Nat.log2
   a
Nat.lt_compat:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   lt
Nat.shiftr_div_pow2:
  forall
   a
   n : nat,
  Nat.shiftr
   a
   n =
  a /
  2
  ^ n
Nat.setbit_spec':
  forall
   a
   n : nat,
  Nat.setbit
   a
   n =
  Nat.lor
   a
   (2
   ^ n)
Nat.A'A_left:
  forall
   (A : 
   nat ->
   Prop)
   (z : nat),
  (forall
   n : nat,
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   n) ->
  forall
   n : nat,
  n <=
  z ->
  A n
Nat.land_spec:
  forall
   a
   b
   n : nat,
  Nat.testbit
   (Nat.land
   a
   b)
   n =
  Nat.testbit
   a
   n &&
  Nat.testbit
   b
   n
Nat.compare_nle_iff:
  forall
   x
   y : nat,
  (x
   ?= y) =
  Gt <->
  ~
  x <=
  y
Nat.lcm_eq_0:
  forall
   n
   m : nat,
  Nat.lcm
   n
   m =
  0 <->
  n =
  0 \/
  m =
  0
Nat.lor_eq_0_iff:
  forall
   a
   b : nat,
  Nat.lor
   a
   b =
  0 <->
  a =
  0 /\
  b =
  0
Nat.compare_nge_iff:
  forall
   x
   y : nat,
  (x
   ?= y) =
  Lt <->
  ~
  y <=
  x
Nat.neq_0_r:
  forall
   n : nat,
  n <>
  0 <->
  (exists
   m : nat,
   n =
   S
   m)
Nat.sqrt_up_eqn:
  forall
   a : nat,
  0 <
  a ->
  Nat.sqrt_up
   a =
  S
   (Nat.sqrt
   (Nat.pred
   a))
Nat.ltb_nlt:
  forall
   x
   y : nat,
  (x <?
   y) =
  false <->
  ~
  x <
  y
Nat.bit_log2:
  forall
   a : nat,
  a <>
  0 ->
  Nat.testbit
   a
   (Nat.log2
   a) =
  true
Nat.eq_add_0:
  forall
   n
   m : nat,
  n +
  m =
  0 <->
  n =
  0 /\
  m =
  0
Nat.divide_gcd_iff:
  forall
   n
   m : nat,
  0 <=
  n ->
  Nat.divide
   n
   m <->
  Nat.gcd
   n
   m =
  n
Nat.eq_mul_0:
  forall
   n
   m : nat,
  n *
  m =
  0 <->
  n =
  0 \/
  m =
  0
Nat.divide_antisym_nonneg:
  forall
   n
   m : nat,
  0 <=
  n ->
  0 <=
  m ->
  Nat.divide
   n
   m ->
  Nat.divide
   m
   n ->
  n =
  m
Nat.leb_nle:
  forall
   x
   y : nat,
  (x <=?
   y) =
  false <->
  ~
  x <=
  y
Nat.mul_eq_0:
  forall
   n
   m : nat,
  n *
  m =
  0 <->
  n =
  0 \/
  m =
  0
Nat.compare_le_iff:
  forall
   n
   m : nat,
  (n
   ?= m) <>
  Gt <->
  n <=
  m
Nat.ones_spec_iff:
  forall
   n
   m : nat,
  Nat.testbit
   (Nat.ones
   n)
   m =
  true <->
  m <
  n
Nat.lxor_spec:
  forall
   a
   b
   n : nat,
  Nat.testbit
   (Nat.lxor
   a
   b)
   n =
  xorb
   (Nat.testbit
   a
   n)
   (Nat.testbit
   b
   n)
Nat.lor_spec:
  forall
   a
   b
   n : nat,
  Nat.testbit
   (Nat.lor
   a
   b)
   n =
  Nat.testbit
   a
   n
  || 
  Nat.testbit
   b
   n
Nat.gcd_eq_0:
  forall
   n
   m : nat,
  Nat.gcd
   n
   m =
  0 <->
  n =
  0 /\
  m =
  0
Nat.gcd_mod:
  forall
   a
   b : nat,
  b <>
  0 ->
  Nat.gcd
   (a
   mod b)
   b =
  Nat.gcd
   b
   a
Nat.compare_ge_iff:
  forall
   x
   y : nat,
  (x
   ?= y) <>
  Lt <->
  y <=
  x
Nat.le_neq:
  forall
   n
   m : nat,
  n <
  m <->
  n <=
  m /\
  n <>
  m
Nat.odd_pred:
  forall
   n : nat,
  n <>
  0 ->
  Nat.odd
   (Nat.pred
   n) =
  Nat.even
   n
Nat.even_pow:
  forall
   a
   b : nat,
  b <>
  0 ->
  Nat.even
   (a
   ^ b) =
  Nat.even
   a
Nat.mul_le_mono_neg_l:
  forall
   n
   m
   p : nat,
  p <
  0 ->
  n <=
  m <->
  p *
  m <=
  p *
  n
Nat.mul_le_mono_pos_r:
  forall
   n
   m
   p : nat,
  0 <
  p ->
  n <=
  m <->
  n *
  p <=
  m *
  p
Nat.odd_pow:
  forall
   a
   b : nat,
  b <>
  0 ->
  Nat.odd
   (a
   ^ b) =
  Nat.odd
   a
Nat.double_bits_succ:
  forall
   a
   n : nat,
  Nat.testbit
   (2 *
   a)
   (S
   n) =
  Nat.testbit
   a
   n
Nat.testbit_even_succ':
  forall
   a
   n : nat,
  Nat.testbit
   (2 *
   a)
   (S
   n) =
  Nat.testbit
   a
   n
Nat.div2_bits:
  forall
   a
   n : nat,
  Nat.testbit
   (a /
   2)
   n =
  Nat.testbit
   a
   (S
   n)
Nat.mul_le_mono_pos_l:
  forall
   n
   m
   p : nat,
  0 <
  p ->
  n <=
  m <->
  p *
  n <=
  p *
  m
Nat.lor_lnot_diag_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.lor
   a
   (Nat.lnot
   a
   n) =
  Nat.ones
   n
Nat.add_pred_l:
  forall
   n
   m : nat,
  n <>
  0 ->
  Nat.pred
   n +
  m =
  Nat.pred
   (n +
   m)
Nat.div_le_compat_l:
  forall
   p
   q
   r : nat,
  0 <
  q <=
  r ->
  p /
  r <=
  p /
  q
Nat.le_1_r:
  forall
   n : nat,
  n <=
  1 <->
  n =
  0 \/
  n =
  1
Nat.lnot_sub_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.lnot
   a
   n =
  Nat.ones
   n -
  a
Nat.testbit_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.testbit
Nat.even_pred:
  forall
   n : nat,
  n <>
  0 ->
  Nat.even
   (Nat.pred
   n) =
  Nat.odd
   n
Nat.sqrt_up_mul_above:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  Nat.sqrt_up
   (a *
   b) <=
  Nat.sqrt_up
   a *
  Nat.sqrt_up
   b
Nat.mul_le_mono_neg_r:
  forall
   n
   m
   p : nat,
  p <
  0 ->
  n <=
  m <->
  m *
  p <=
  n *
  p
Nat.add_lnot_diag_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  a +
  Nat.lnot
   a
   n =
  Nat.ones
   n
Nat.ldiff_ones_l_low:
  forall
   a
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.ldiff
   (Nat.ones
   n)
   a =
  Nat.lnot
   a
   n
Nat.add_bit0:
  forall
   a
   b : nat,
  Nat.testbit
   (a +
   b)
   0 =
  xorb
   (Nat.testbit
   a
   0)
   (Nat.testbit
   b
   0)
Nat.eqb_compat:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   eq))
   Nat.eqb
Nat.add_pred_r:
  forall
   n
   m : nat,
  m <>
  0 ->
  n +
  Nat.pred
   m =
  Nat.pred
   (n +
   m)
Nat.clearbit_neq:
  forall
   a
   n
   m : nat,
  n <>
  m ->
  Nat.testbit
   (Nat.clearbit
   a
   n)
   m =
  Nat.testbit
   a
   m
Nat.pow_inj_l:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  a
  ^ c =
  b
  ^ c ->
  a =
  b
Nat.pow2_bits_eqb:
  forall
   n
   m : nat,
  Nat.testbit
   (2
   ^ n)
   m =
  (n =?
   m)
Nat.shiftr_shiftl_r:
  forall
   a
   n
   m : nat,
  n <=
  m ->
  Nat.shiftr
   (Nat.shiftl
   a
   n)
   m =
  Nat.shiftr
   a
   (m -
   n)
Nat.odd_add_mul_even:
  forall
   n
   m
   p : nat,
  Nat.Even
   m ->
  Nat.odd
   (n +
   m *
   p) =
  Nat.odd
   n
Nat.compare_ngt_iff:
  forall
   x
   y : nat,
  (x
   ?= y) <>
  Gt <->
  ~
  y <
  x
Nat.ltb_compare:
  forall
   x
   y : nat,
  (x <?
   y) =
  match
   x
   ?= y
  with
  | Lt =>
   true
  | _ =>
   false
  end
Nat.eqb_compare:
  forall
   x
   y : nat,
  (x =?
   y) =
  match
   x
   ?= y
  with
  | Eq =>
   true
  | _ =>
   false
  end
Nat.log2_up_double:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2_up
   (2 *
   a) =
  S
   (Nat.log2_up
   a)
Nat.even_add_mul_even:
  forall
   n
   m
   p : nat,
  Nat.Even
   m ->
  Nat.even
   (n +
   m *
   p) =
  Nat.even
   n
Nat.shiftr_shiftl_l:
  forall
   a
   n
   m : nat,
  m <=
  n ->
  Nat.shiftr
   (Nat.shiftl
   a
   n)
   m =
  Nat.shiftl
   a
   (n -
   m)
Nat.log2_up_eqn:
  forall
   a : nat,
  1 <
  a ->
  Nat.log2_up
   a =
  S
   (Nat.log2
   (Nat.pred
   a))
Nat.log2_up_succ_pow2:
  forall
   a : nat,
  0 <=
  a ->
  Nat.log2_up
   (S
   (2
   ^ a)) =
  S a
Nat.eq_pred_0:
  forall
   n : nat,
  Nat.pred
   n =
  0 <->
  n =
  0 \/
  n =
  1
Nat.pow_succ_r:
  forall
   a
   b : nat,
  0 <=
  b ->
  a
  ^ 
  S b =
  a *
  a
  ^ b
Nat.leb_compare:
  forall
   x
   y : nat,
  (x <=?
   y) =
  match
   x
   ?= y
  with
  | Gt =>
   false
  | _ =>
   true
  end
Nat.log2_double:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2
   (2 *
   a) =
  S
   (Nat.log2
   a)
Nat.compare_nlt_iff:
  forall
   x
   y : nat,
  (x
   ?= y) <>
  Lt <->
  ~
  x <
  y
Nat.setbit_neq:
  forall
   a
   n
   m : nat,
  n <>
  m ->
  Nat.testbit
   (Nat.setbit
   a
   n)
   m =
  Nat.testbit
   a
   m
Nat.bit0_eqb:
  forall
   a : nat,
  Nat.testbit
   a
   0 =
  (a
   mod 2 =?
   1)
Nat.odd_sub:
  forall
   n
   m : nat,
  m <=
  n ->
  Nat.odd
   (n -
   m) =
  xorb
   (Nat.odd
   n)
   (Nat.odd
   m)
Nat.pow_lt_mono_r_iff:
  forall
   a
   b
   c : nat,
  1 <
  a ->
  b <
  c <->
  a
  ^ b <
  a
  ^ c
Nat.pow_le_mono_r:
  forall
   a
   b
   c : nat,
  a <>
  0 ->
  b <=
  c ->
  a
  ^ b <=
  a
  ^ c
Nat.even_add_mul_2:
  forall
   n
   m : nat,
  Nat.even
   (n +
   2 *
   m) =
  Nat.even
   n
Nat.odd_add_mul_2:
  forall
   n
   m : nat,
  Nat.odd
   (n +
   2 *
   m) =
  Nat.odd
   n
Nat.mod_divide:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  mod b =
  0 <->
  Nat.divide
   b
   a
Nat.mod_small_iff:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  mod b =
  a <->
  a <
  b
Nat.div_le_mono:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  a <=
  b ->
  a /
  c <=
  b /
  c
Nat.pow_lt_mono_l:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  a <
  b ->
  a
  ^ c <
  b
  ^ c
Nat.pred_lt_mono:
  forall
   n
   m : nat,
  n <>
  0 ->
  n <
  m <->
  Nat.pred
   n <
  Nat.pred
   m
Nat.sqrt_up_le_square:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  a <=
  b *
  b <->
  Nat.sqrt_up
   a <=
  b
Nat.A'A_right:
  forall
   (A : 
   nat ->
   Prop)
   (z : nat),
  (forall
   n : nat,
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   n) ->
  forall
   n : nat,
  z <=
  n ->
  A n
Nat.add_dichotomy:
  forall
   n
   m : nat,
  (exists
   p : nat,
   p +
   n =
   m) \/
  (exists
   p : nat,
   p +
   m =
   n)
Nat.setbit_eqb:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.setbit
   a
   n)
   m =
  (n =?
   m)
  || 
  Nat.testbit
   a
   m
Nat.even_sub:
  forall
   n
   m : nat,
  m <=
  n ->
  Nat.even
   (n -
   m) =
  Bool.eqb
   (Nat.even
   n)
   (Nat.even
   m)
Nat.div_small_iff:
  forall
   a
   b : nat,
  b <>
  0 ->
  a /
  b =
  0 <->
  a <
  b
Nat.mod_bound_pos:
  forall
   x
   y : nat,
  0 <=
  x ->
  0 <
  y ->
  0 <=
  x
  mod y <
  y
Nat.log2_shiftl:
  forall
   a
   n : nat,
  a <>
  0 ->
  Nat.log2
   (Nat.shiftl
   a
   n) =
  Nat.log2
   a +
  n
Nat.pow_inj_r:
  forall
   a
   b
   c : nat,
  1 <
  a ->
  a
  ^ b =
  a
  ^ c ->
  b =
  c
Nat.lnot_spec_low:
  forall
   a
   n
   m : nat,
  m <
  n ->
  Nat.testbit
   (Nat.lnot
   a
   n)
   m =
  negb
   (Nat.testbit
   a
   m)
Nat.land_ones:
  forall
   a
   n : nat,
  Nat.land
   a
   (Nat.ones
   n) =
  a
  mod 
  2
  ^ n
Nat.mul_succ_div_gt:
  forall
   a
   b : nat,
  b <>
  0 ->
  a <
  b *
  S
   (a /
   b)
Nat.add_sqrt_le:
  forall
   a
   b : nat,
  Nat.sqrt
   a +
  Nat.sqrt
   b <=
  Nat.sqrt
   (2 *
   (a +
   b))
Nat.ldiff_land_low:
  forall
   a
   b
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.ldiff
   a
   b =
  Nat.land
   a
   (Nat.lnot
   b
   n)
Nat.log2_up_mul_above:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  Nat.log2_up
   (a *
   b) <=
  Nat.log2_up
   a +
  Nat.log2_up
   b
Nat.lt_exists_pred:
  forall
   z
   n : nat,
  z <
  n ->
  exists
   k : nat,
   n =
   S
   k /\
   z <=
   k
Nat.le_exists_sub:
  forall
   n
   m : nat,
  n <=
  m ->
  exists
   p : nat,
   m =
   p +
   n /\
   0 <=
   p
Nat.ldiff_spec:
  forall
   a
   b
   n : nat,
  Nat.testbit
   (Nat.ldiff
   a
   b)
   n =
  Nat.testbit
   a
   n &&
  negb
   (Nat.testbit
   b
   n)
Nat.shiftl_specif_high:
  forall
   a
   n
   m : nat,
  n <=
  m ->
  Nat.testbit
   (Nat.shiftl
   a
   n)
   m =
  Nat.testbit
   a
   (m -
   n)
Nat.add_sub_eq_nz:
  forall
   n
   m
   p : nat,
  p <>
  0 ->
  n -
  m =
  p ->
  m +
  p =
  n
Nat.log2_lt_pow2:
  forall
   a
   b : nat,
  0 <
  a ->
  a <
  2
  ^ b <->
  Nat.log2
   a <
  b
Nat.div_unique_exact:
  forall
   a
   b
   q : nat,
  b <>
  0 ->
  a =
  b *
  q ->
  q =
  a /
  b
Nat.pow_gt_1:
  forall
   a
   b : nat,
  1 <
  a ->
  b <>
  0 ->
  1 <
  a
  ^ b
Nat.div_str_pos_iff:
  forall
   a
   b : nat,
  b <>
  0 ->
  0 <
  a /
  b <->
  b <=
  a
Nat.log2_pred_pow2:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2
   (Nat.pred
   (2
   ^ a)) =
  Nat.pred
   a
Nat.pow_eq_0_iff:
  forall
   a
   b : nat,
  a
  ^ b =
  0 <->
  b <>
  0 /\
  a =
  0
Nat.shiftl_spec_high':
  forall
   a
   n
   m : nat,
  n <=
  m ->
  Nat.testbit
   (Nat.shiftl
   a
   n)
   m =
  Nat.testbit
   a
   (m -
   n)
Nat.testbit_odd_0:
  forall
   a : nat,
  Nat.testbit
   (2 *
   a +
   1)
   0 =
  true
Nat.add_le_mul:
  forall
   a
   b : nat,
  1 <
  a ->
  1 <
  b ->
  a +
  b <=
  a *
  b
Nat.log2_up_lt_pow2:
  forall
   a
   b : nat,
  0 <
  a ->
  2
  ^ b <
  a <->
  b <
  Nat.log2_up
   a
Nat.pow_le_mono_r_iff:
  forall
   a
   b
   c : nat,
  1 <
  a ->
  b <=
  c <->
  a
  ^ b <=
  a
  ^ c
Nat.div2_odd:
  forall
   a : nat,
  a =
  2 *
  Nat.div2
   a +
  Nat.b2n
   (Nat.odd
   a)
Nat.div_le_upper_bound:
  forall
   a
   b
   q : nat,
  b <>
  0 ->
  a <=
  b *
  q ->
  a /
  b <=
  q
Nat.mul_id_l:
  forall
   n
   m : nat,
  m <>
  0 ->
  n *
  m =
  m <->
  n =
  1
Nat.sqrt_up_lt_square:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  b *
  b <
  a <->
  b <
  Nat.sqrt_up
   a
Nat.mul_le_mono_nonneg:
  forall
   n
   m
   p
   q : nat,
  0 <=
  n ->
  n <=
  m ->
  0 <=
  p ->
  p <=
  q ->
  n *
  p <=
  m *
  q
Nat.double_above:
  forall
   n
   m : nat,
  n <
  m ->
  2 *
  n +
  1 <
  2 *
  m
Nat.mul_cancel_l:
  forall
   n
   m
   p : nat,
  p <>
  0 ->
  p *
  n =
  p *
  m <->
  n =
  m
Nat.gauss:
  forall
   n
   m
   p : nat,
  Nat.divide
   n
   (m *
   p) ->
  Nat.gcd
   n
   m =
  1 ->
  Nat.divide
   n
   p
Nat.mul_id_r:
  forall
   n
   m : nat,
  n <>
  0 ->
  n *
  m =
  n <->
  m =
  1
Nat.gcd_bezout_pos_pos:
  forall
   n : nat,
  0 <
  n ->
  forall
   m : nat,
  0 <
  m ->
  Nat.Bezout
   n
   m
   (Nat.gcd
   n
   m) /\
  Nat.Bezout
   m
   n
   (Nat.gcd
   n
   m)
Nat.div_lt_upper_bound:
  forall
   a
   b
   q : nat,
  b <>
  0 ->
  a <
  b *
  q ->
  a /
  b <
  q
Nat.mul_cancel_r:
  forall
   n
   m
   p : nat,
  p <>
  0 ->
  n *
  p =
  m *
  p <->
  n =
  m
Nat.div_le_lower_bound:
  forall
   a
   b
   q : nat,
  b <>
  0 ->
  b *
  q <=
  a ->
  q <=
  a /
  b
Nat.mul_2_mono_l:
  forall
   n
   m : nat,
  n <
  m ->
  1 +
  2 *
  n <
  2 *
  m
Nat.pred_inj:
  forall
   n
   m : nat,
  n <>
  0 ->
  m <>
  0 ->
  Nat.pred
   n =
  Nat.pred
   m ->
  n =
  m
Nat.div_unique:
  forall
   a
   b
   q
   r : nat,
  r <
  b ->
  a =
  b *
  q +
  r ->
  q =
  a /
  b
Nat.crossmul_le_addsquare:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  b *
  a +
  a *
  b <=
  a *
  a +
  b *
  b
Nat.mul_divide_cancel_r:
  forall
   n
   m
   p : nat,
  p <>
  0 ->
  Nat.divide
   (n *
   p)
   (m *
   p) <->
  Nat.divide
   n
   m
Nat.pow_le_mono_l_iff:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  a <=
  b <->
  a
  ^ c <=
  b
  ^ c
Nat.sqrt_specif:
  forall
   n : nat,
  Nat.sqrt
   n *
  Nat.sqrt
   n <=
  n <
  S
   (Nat.sqrt
   n) *
  S
   (Nat.sqrt
   n)
Nat.mod_unique:
  forall
   a
   b
   q
   r : nat,
  r <
  b ->
  a =
  b *
  q +
  r ->
  r =
  a
  mod b
Nat.testbit_0_r:
  forall
   (a : nat)
   (b : bool),
  Nat.testbit
   (2 *
   a +
   Nat.b2n
   b)
   0 =
  b
Nat.mul_divide_cancel_l:
  forall
   n
   m
   p : nat,
  p <>
  0 ->
  Nat.divide
   (p *
   n)
   (p *
   m) <->
  Nat.divide
   n
   m
Nat.sqrt_spec':
  forall
   a : nat,
  Nat.sqrt
   a *
  Nat.sqrt
   a <=
  a <
  S
   (Nat.sqrt
   a) *
  S
   (Nat.sqrt
   a)
Nat.pow_lt_mono_l_iff:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  a <
  b <->
  a
  ^ c <
  b
  ^ c
Nat.add_square_le:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  a *
  a +
  b *
  b <=
  (a +
   b) *
  (a +
   b)
Nat.div_mul_le:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c *
  (a /
   b) <=
  c *
  a /
  b
Nat.add_b2n_double_bit0:
  forall
   (a0 : bool)
   (a : nat),
  Nat.testbit
   (Nat.b2n
   a0 +
   2 *
   a)
   0 =
  a0
Nat.odd_bitwise:
  forall
   (op : 
   bool ->
   bool ->
   bool)
   (n
   a
   b : nat),
  Nat.odd
   (Nat.bitwise
   op
   (S
   n)
   a
   b) =
  op
   (Nat.odd
   a)
   (Nat.odd
   b)
Nat.log2_mul_below:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.log2
   a +
  Nat.log2
   b <=
  Nat.log2
   (a *
   b)
Nat.gcd_unique_alt':
  forall
   n
   m
   p : nat,
  (forall
   q : nat,
   Nat.divide
   q
   p <->
   Nat.divide
   q
   n /\
   Nat.divide
   q
   m) ->
  Nat.gcd
   n
   m =
  p
Nat.add_mod_idemp_l:
  forall
   a
   b
   n : nat,
  n <>
  0 ->
  (a
   mod n +
   b)
  mod n =
  (a +
   b)
  mod n
Nat.max_spec_le:
  forall
   n
   m : nat,
  n <=
  m /\
  Nat.max
   n
   m =
  m \/
  m <=
  n /\
  Nat.max
   n
   m =
  n
Nat.mul_mod_idemp_r:
  forall
   a
   b
   n : nat,
  n <>
  0 ->
  (a *
   (b
   mod n))
  mod n =
  (a *
   b)
  mod n
Nat.log2_le_pow2:
  forall
   a
   b : nat,
  0 <
  a ->
  2
  ^ b <=
  a <->
  b <=
  Nat.log2
   a
Nat.sqrt_sqrt_up_spec:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt
   a *
  Nat.sqrt
   a <=
  a <=
  Nat.sqrt_up
   a *
  Nat.sqrt_up
   a
Nat.shiftr_spec:
  forall
   a
   n
   m : nat,
  0 <=
  m ->
  Nat.testbit
   (Nat.shiftr
   a
   n)
   m =
  Nat.testbit
   a
   (m +
   n)
Nat.ones_mod_pow2:
  forall
   n
   m : nat,
  m <=
  n ->
  Nat.ones
   n
  mod 
  2
  ^ m =
  Nat.ones
   m
Nat.mod_add:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  (a +
   b *
   c)
  mod c =
  a
  mod c
Nat.log2_up_le_pow2:
  forall
   a
   b : nat,
  0 <
  a ->
  a <=
  2
  ^ b <->
  Nat.log2_up
   a <=
  b
Nat.sqrt_up_mul_below:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.pred
   (Nat.sqrt_up
   a) *
  Nat.pred
   (Nat.sqrt_up
   b) <
  Nat.sqrt_up
   (a *
   b)
Nat.divide_div:
  forall
   a
   b
   c : nat,
  a <>
  0 ->
  Nat.divide
   a
   b ->
  Nat.divide
   b
   c ->
  Nat.divide
   (b /
   a)
   (c /
   a)
Nat.add_mod_idemp_r:
  forall
   a
   b
   n : nat,
  n <>
  0 ->
  (a +
   b
   mod n)
  mod n =
  (a +
   b)
  mod n
Nat.clearbit_eqb:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.clearbit
   a
   n)
   m =
  Nat.testbit
   a
   m &&
  negb
   (n =?
   m)
Nat.min_spec_le:
  forall
   n
   m : nat,
  n <=
  m /\
  Nat.min
   n
   m =
  n \/
  m <=
  n /\
  Nat.min
   n
   m =
  m
Nat.mul_mod_idemp_l:
  forall
   a
   b
   n : nat,
  n <>
  0 ->
  (a
   mod n *
   b)
  mod n =
  (a *
   b)
  mod n
Nat.mul_lt_mono_nonneg:
  forall
   n
   m
   p
   q : nat,
  0 <=
  n ->
  n <
  m ->
  0 <=
  p ->
  p <
  q ->
  n *
  p <
  m *
  q
Nat.eq_mul_1:
  forall
   n
   m : nat,
  n *
  m =
  1 <->
  n =
  1 /\
  m =
  1
Nat.mul_eq_1:
  forall
   n
   m : nat,
  n *
  m =
  1 <->
  n =
  1 /\
  m =
  1
Nat.neq_mul_0:
  forall
   n
   m : nat,
  n <>
  0 /\
  m <>
  0 <->
  n *
  m <>
  0
Nat.double_below:
  forall
   n
   m : nat,
  n <=
  m ->
  2 *
  n <
  2 *
  m +
  1
Nat.testbit_even_succ:
  forall
   a
   n : nat,
  0 <=
  n ->
  Nat.testbit
   (2 *
   a)
   (S
   n) =
  Nat.testbit
   a
   n
Nat.div_mod:
  forall
   x
   y : nat,
  y <>
  0 ->
  x =
  y *
  (x /
   y) +
  x
  mod y
Nat.mod_eq:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  mod b =
  a -
  b *
  (a /
   b)
Nat.testbit_odd_succ':
  forall
   a
   n : nat,
  Nat.testbit
   (2 *
   a +
   1)
   (S
   n) =
  Nat.testbit
   a
   n
Nat.gcd_unique':
  forall
   n
   m
   p : nat,
  Nat.divide
   p
   n ->
  Nat.divide
   p
   m ->
  (forall
   q : nat,
   Nat.divide
   q
   n ->
   Nat.divide
   q
   m ->
   Nat.divide
   q
   p) ->
  Nat.gcd
   n
   m =
  p
Nat.div2_bitwise:
  forall
   (op : 
   bool ->
   bool ->
   bool)
   (n
   a
   b : nat),
  Nat.div2
   (Nat.bitwise
   op
   (S
   n)
   a
   b) =
  Nat.bitwise
   op
   n
   (Nat.div2
   a)
   (Nat.div2
   b)
Nat.sqrt_up_succ_or:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt_up
   (S
   a) =
  S
   (Nat.sqrt_up
   a) \/
  Nat.sqrt_up
   (S
   a) =
  Nat.sqrt_up
   a
Nat.pow_le_mono:
  forall
   a
   b
   c
   d : nat,
  a <>
  0 ->
  a <=
  c ->
  b <=
  d ->
  a
  ^ b <=
  c
  ^ d
Nat.log2_up_eq_succ_is_pow2:
  forall
   a : nat,
  Nat.log2_up
   (S
   a) =
  S
   (Nat.log2_up
   a) ->
  exists
   b : nat,
   a =
   2
   ^ b
Nat.pow2_bits_false:
  forall
   n
   m : nat,
  n <>
  m ->
  Nat.testbit
   (2
   ^ n)
   m =
  false
Nat.pow_add_lower:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  a
  ^ c +
  b
  ^ c <=
  (a +
   b)
  ^ c
Nat.log2_succ_double:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2
   (2 *
   a +
   1) =
  S
   (Nat.log2
   a)
Nat.ones_add:
  forall
   n
   m : nat,
  Nat.ones
   (m +
   n) =
  2
  ^ m *
  Nat.ones
   n +
  Nat.ones
   m
Nat.lt_exists_pred_strong:
  forall
   z
   n
   m : nat,
  z <
  m ->
  m <=
  n ->
  exists
   k : nat,
   m =
   S
   k /\
   z <=
   k
Nat.max_spec:
  forall
   n
   m : nat,
  n <
  m /\
  Nat.max
   n
   m =
  m \/
  m <=
  n /\
  Nat.max
   n
   m =
  n
Nat.div_add_l:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  (a *
   b +
   c) /
  b =
  a +
  c /
  b
Nat.add_b2n_double_div2:
  forall
   (a0 : bool)
   (a : nat),
  (Nat.b2n
   a0 +
   2 *
   a) /
  2 =
  a
Nat.mul_mod:
  forall
   a
   b
   n : nat,
  n <>
  0 ->
  (a *
   b)
  mod n =
  (a
   mod n *
   (b
   mod n))
  mod n
Nat.div_add:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  (a +
   b *
   c) /
  c =
  a /
  c +
  b
Nat.min_spec:
  forall
   n
   m : nat,
  n <
  m /\
  Nat.min
   n
   m =
  n \/
  m <=
  n /\
  Nat.min
   n
   m =
  m
Nat.add_mod:
  forall
   a
   b
   n : nat,
  n <>
  0 ->
  (a +
   b)
  mod n =
  (a
   mod n +
   b
   mod n)
  mod n
Nat.pow_lt_mono:
  forall
   a
   b
   c
   d : nat,
  0 <
  a <
  c ->
  0 <
  b <
  d ->
  a
  ^ b <
  c
  ^ d
Nat.Bezout_wd:
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff)))
   Nat.Bezout
Nat.log2_same:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.log2
   a =
  Nat.log2
   b ->
  a <
  2 *
  b
Nat.log2_eq_succ_is_pow2:
  forall
   a : nat,
  Nat.log2
   (S
   a) =
  S
   (Nat.log2
   a) ->
  exists
   b : nat,
   S
   a =
   2
   ^ b
Nat.exists_div2:
  forall
   a : nat,
  exists
   (a' : nat) 
  (b : bool),
   a =
   2 *
   a' +
   Nat.b2n
   b
Nat.log2_up_mul_below:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.log2_up
   a +
  Nat.log2_up
   b <=
  S
   (Nat.log2_up
   (a *
   b))
Nat.log2_up_same:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.log2_up
   a =
  Nat.log2_up
   b ->
  a <
  2 *
  b
Nat.max_monotone:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   le
   le)
   f ->
  forall
   x
   y : nat,
  Nat.max
   (f
   x)
   (f
   y) =
  f
   (Nat.max
   x
   y)
Nat.lt_0_mul:
  forall
   n
   m : nat,
  0 <
  n *
  m <->
  0 <
  n /\
  0 <
  m \/
  m <
  0 /\
  n <
  0
Nat.add3_bit0:
  forall
   a
   b
   c : nat,
  Nat.testbit
   (a +
   b +
   c)
   0 =
  xorb
   (xorb
   (Nat.testbit
   a
   0)
   (Nat.testbit
   b
   0))
   (Nat.testbit
   c
   0)
Nat.sqrt_unique:
  forall
   a
   b : nat,
  b *
  b <=
  a <
  S b *
  S b ->
  Nat.sqrt
   a =
  b
Nat.log2_mul_above:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  Nat.log2
   (a *
   b) <=
  Nat.log2
   a +
  Nat.log2
   b +
  1
Nat.min_monotone:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   le
   le)
   f ->
  forall
   x
   y : nat,
  Nat.min
   (f
   x)
   (f
   y) =
  f
   (Nat.min
   x
   y)
Nat.div_mul_cancel_l:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c <>
  0 ->
  c *
  a /
  (c *
   b) =
  a /
  b
Nat.div_pow2_bits:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (a /
   2
   ^ n)
   m =
  Nat.testbit
   a
   (m +
   n)
Nat.div_mul_cancel_r:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c <>
  0 ->
  a *
  c /
  (b *
   c) =
  a /
  b
Nat.case_analysis:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  A 0 ->
  (forall
   n : nat,
   A
   (S
   n)) ->
  forall
   n : nat,
  A n
Nat.shiftl_spec_high:
  forall
   a
   n
   m : nat,
  0 <=
  m ->
  n <=
  m ->
  Nat.testbit
   (Nat.shiftl
   a
   n)
   m =
  Nat.testbit
   a
   (m -
   n)
Nat.eq_mul_1_nonneg':
  forall
   n
   m : nat,
  0 <=
  m ->
  n *
  m =
  1 ->
  n =
  1 /\
  m =
  1
Nat.div_exact:
  forall
   a
   b : nat,
  b <>
  0 ->
  a =
  b *
  (a /
   b) <->
  a
  mod b =
  0
Nat.eq_mul_1_nonneg:
  forall
   n
   m : nat,
  0 <=
  n ->
  n *
  m =
  1 ->
  n =
  1 /\
  m =
  1
Nat.divide_div_mul_exact:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  Nat.divide
   b
   a ->
  c *
  a /
  b =
  c *
  (a /
   b)
Nat.div_div:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c <>
  0 ->
  a /
  b /
  c =
  a /
  (b *
   c)
Nat.mul_pow2_bits_add:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (a *
   2
   ^ n)
   (m +
   n) =
  Nat.testbit
   a
   m
Nat.testbit_spec':
  forall
   a
   n : nat,
  Nat.b2n
   (Nat.testbit
   a
   n) =
  (a /
   2
   ^ n)
  mod 2
Nat.add_log2_up_lt:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.log2_up
   a +
  Nat.log2_up
   b <
  2 *
  Nat.log2_up
   (a +
   b)
Nat.testbit_succ_r:
  forall
   (a : nat)
   (b : bool)
   (n : nat),
  Nat.testbit
   (2 *
   a +
   Nat.b2n
   b)
   (S
   n) =
  Nat.testbit
   a
   n
Nat.add_log2_lt:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <
  b ->
  Nat.log2
   a +
  Nat.log2
   b <
  2 *
  Nat.log2
   (a +
   b)
Nat.ones_div_pow2:
  forall
   n
   m : nat,
  m <=
  n ->
  Nat.ones
   n /
  2
  ^ m =
  Nat.ones
   (n -
   m)
Nat.setbit_iff:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.setbit
   a
   n)
   m =
  true <->
  n =
  m \/
  Nat.testbit
   a
   m =
  true
Nat.lnot_ldiff_low:
  forall
   a
   b
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.log2
   b <
  n ->
  Nat.lnot
   (Nat.ldiff
   a
   b)
   n =
  Nat.lor
   (Nat.lnot
   a
   n)
   b
Nat.mul_pow2_bits_low:
  forall
   a
   n
   m : nat,
  m <
  n ->
  Nat.testbit
   (a *
   2
   ^ n)
   m =
  false
Nat.mod_pow2_bits_high:
  forall
   a
   n
   m : nat,
  n <=
  m ->
  Nat.testbit
   (a
   mod 
   2
   ^ n)
   m =
  false
Nat.mod_divides:
  forall
   a
   b : nat,
  b <>
  0 ->
  a
  mod b =
  0 <->
  (exists
   c : nat,
   a =
   b *
   c)
Nat.sqrt_spec:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt
   a *
  Nat.sqrt
   a <=
  a <
  S
   (Nat.sqrt
   a) *
  S
   (Nat.sqrt
   a)
Nat.lcm_equiv1:
  forall
   a
   b : nat,
  Nat.gcd
   a
   b <>
  0 ->
  a *
  (b /
   Nat.gcd
   a
   b) =
  a *
  b /
  Nat.gcd
   a
   b
Nat.mod_pow2_bits_low:
  forall
   a
   n
   m : nat,
  m <
  n ->
  Nat.testbit
   (a
   mod 
   2
   ^ n)
   m =
  Nat.testbit
   a
   m
Nat.lcm_equiv2:
  forall
   a
   b : nat,
  Nat.gcd
   a
   b <>
  0 ->
  a /
  Nat.gcd
   a
   b *
  b =
  a *
  b /
  Nat.gcd
   a
   b
Nat.sqrt_up_spec:
  forall
   a : nat,
  0 <
  a ->
  Nat.pred
   (Nat.sqrt_up
   a) *
  Nat.pred
   (Nat.sqrt_up
   a) <
  a <=
  Nat.sqrt_up
   a *
  Nat.sqrt_up
   a
Nat.shiftr_eq_0_iff:
  forall
   a
   n : nat,
  Nat.shiftr
   a
   n =
  0 <->
  a =
  0 \/
  0 <
  a /\
  Nat.log2
   a <
  n
Nat.min_unicity:
  forall
   n
   m
   p : nat,
  n <
  m /\
  p =
  n \/
  m <=
  n /\
  p =
  m ->
  p =
  Nat.min
   n
   m
Nat.max_unicity:
  forall
   n
   m
   p : nat,
  n <
  m /\
  p =
  m \/
  m <=
  n /\
  p =
  n ->
  p =
  Nat.max
   n
   m
Nat.add_sqrt_up_le:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  Nat.sqrt_up
   a +
  Nat.sqrt_up
   b <=
  S
   (Nat.sqrt_up
   (2 *
   (a +
   b)))
Nat.mul_mod_distr_l:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c <>
  0 ->
  (c *
   a)
  mod 
  (c *
   b) =
  c *
  (a
   mod b)
Nat.log2_bits_unique:
  forall
   a
   n : nat,
  Nat.testbit
   a
   n =
  true ->
  (forall
   m : nat,
   n <
   m ->
   Nat.testbit
   a
   m =
   false) ->
  Nat.log2
   a =
  n
Nat.mul_mod_distr_r:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c <>
  0 ->
  (a *
   c)
  mod 
  (b *
   c) =
  a
  mod b *
  c
Nat.gcd_div_gcd:
  forall
   a
   b
   g : nat,
  g <>
  0 ->
  g =
  Nat.gcd
   a
   b ->
  Nat.gcd
   (a /
   g)
   (b /
   g) =
  1
Nat.log2_spec:
  forall
   n : nat,
  0 <
  n ->
  2
  ^ 
  Nat.log2
   n <=
  n <
  2
  ^ 
  S
   (Nat.log2
   n)
Nat.testbit_odd_succ:
  forall
   a
   n : nat,
  0 <=
  n ->
  Nat.testbit
   (2 *
   a +
   1)
   (S
   n) =
  Nat.testbit
   a
   n
Nat.induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  A 0 ->
  (forall
   n : nat,
   A
   n ->
   A
   (S
   n)) ->
  forall
   n : nat,
  A n
Nat.square_add_le:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  (a +
   b) *
  (a +
   b) <=
  2 *
  (a *
   a +
   b *
   b)
Nat.central_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   A
   n <->
   A
   (S
   n)) ->
  forall
   n : nat,
  A n
Nat.lnot_lor_low:
  forall
   a
   b
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.log2
   b <
  n ->
  Nat.lnot
   (Nat.lor
   a
   b)
   n =
  Nat.land
   (Nat.lnot
   a
   n)
   (Nat.lnot
   b
   n)
Nat.lnot_land_low:
  forall
   a
   b
   n : nat,
  Nat.log2
   a <
  n ->
  Nat.log2
   b <
  n ->
  Nat.lnot
   (Nat.land
   a
   b)
   n =
  Nat.lor
   (Nat.lnot
   a
   n)
   (Nat.lnot
   b
   n)
Nat.log2_log2_up_spec:
  forall
   a : nat,
  0 <
  a ->
  2
  ^ 
  Nat.log2
   a <=
  a <=
  2
  ^ 
  Nat.log2_up
   a
Nat.log2_up_succ_double:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2_up
   (2 *
   a +
   1) =
  2 +
  Nat.log2
   a
Nat.quadmul_le_squareadd:
  forall
   a
   b : nat,
  0 <=
  a ->
  0 <=
  b ->
  2 *
  2 *
  a *
  b <=
  (a +
   b) *
  (a +
   b)
Nat.gcd_unique_alt:
  forall
   n
   m
   p : nat,
  0 <=
  p ->
  (forall
   q : nat,
   Nat.divide
   q
   p <->
   Nat.divide
   q
   n /\
   Nat.divide
   q
   m) ->
  Nat.gcd
   n
   m =
  p
Nat.lcm_unique_alt:
  forall
   n
   m
   p : nat,
  0 <=
  p ->
  (forall
   q : nat,
   Nat.divide
   p
   q <->
   Nat.divide
   n
   q /\
   Nat.divide
   m
   q) ->
  Nat.lcm
   n
   m =
  p
Nat.bi_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  A 0 ->
  (forall
   n : nat,
   A
   n <->
   A
   (S
   n)) ->
  forall
   n : nat,
  A n
Nat.pow_sub_r:
  forall
   a
   b
   c : nat,
  a <>
  0 ->
  c <=
  b ->
  a
  ^ 
  (b -
   c) =
  a
  ^ b /
  a
  ^ c
Nat.clearbit_iff:
  forall
   a
   n
   m : nat,
  Nat.testbit
   (Nat.clearbit
   a
   n)
   m =
  true <->
  Nat.testbit
   a
   m =
  true /\
  n <>
  m
Nat.sqrt_up_unique:
  forall
   a
   b : nat,
  0 <
  b ->
  Nat.pred
   b *
  Nat.pred
   b <
  a <=
  b *
  b ->
  Nat.sqrt_up
   a =
  b
Nat.pow_div_l:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  a
  mod b =
  0 ->
  (a /
   b)
  ^ c =
  a
  ^ c /
  b
  ^ c
Nat.log2_up_add_le:
  forall
   a
   b : nat,
  a <>
  1 ->
  b <>
  1 ->
  Nat.log2_up
   (a +
   b) <=
  Nat.log2_up
   a +
  Nat.log2_up
   b
Nat.log2_add_le:
  forall
   a
   b : nat,
  a <>
  1 ->
  b <>
  1 ->
  Nat.log2
   (a +
   b) <=
  Nat.log2
   a +
  Nat.log2
   b
Nat.gcd_unique:
  forall
   n
   m
   p : nat,
  0 <=
  p ->
  Nat.divide
   p
   n ->
  Nat.divide
   p
   m ->
  (forall
   q : nat,
   Nat.divide
   q
   n ->
   Nat.divide
   q
   m ->
   Nat.divide
   q
   p) ->
  Nat.gcd
   n
   m =
  p
Nat.lcm_unique:
  forall
   n
   m
   p : nat,
  0 <=
  p ->
  Nat.divide
   n
   p ->
  Nat.divide
   m
   p ->
  (forall
   q : nat,
   Nat.divide
   n
   q ->
   Nat.divide
   m
   q ->
   Nat.divide
   p
   q) ->
  Nat.lcm
   n
   m =
  p
Nat.Rgt_wd:
  forall
   z : nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   (fun
   n
   m : nat
   =>
   m <
   n <=
   z)
Nat.Rlt_wd:
  forall
   z : nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   (fun
   n
   m : nat
   =>
   z <=
   n <
   m)
Nat.testbit_eqb:
  forall
   a
   n : nat,
  Nat.testbit
   a
   n =
  ((a /
   2
   ^ n)
   mod 2 =?
   1)
Nat.gcd_div_factor:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  Nat.divide
   c
   a ->
  Nat.divide
   c
   b ->
  Nat.gcd
   (a /
   c)
   (b /
   c) =
  Nat.gcd
   a
   b /
  c
Nat.log2_log2_up_exact:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2
   a =
  Nat.log2_up
   a <->
  (exists
   b : nat,
   a =
   2
   ^ b)
Nat.mul_lt_pred:
  forall
   p
   q
   n
   m : nat,
  S p =
  q ->
  p *
  n <
  p *
  m <->
  q *
  n +
  m <
  q *
  m +
  n
Nat.mul_pow2_bits_high:
  forall
   a
   n
   m : nat,
  n <=
  m ->
  Nat.testbit
   (a *
   2
   ^ n)
   m =
  Nat.testbit
   a
   (m -
   n)
Nat.log2_up_spec:
  forall
   a : nat,
  1 <
  a ->
  2
  ^ 
  Nat.pred
   (Nat.log2_up
   a) <
  a <=
  2
  ^ 
  Nat.log2_up
   a
Nat.log2_up_eq_succ_iff_pow2:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2_up
   (S
   a) =
  S
   (Nat.log2_up
   a) <->
  (exists
   b : nat,
   a =
   2
   ^ b)
Nat.log2_up_mul_pow2:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <=
  b ->
  Nat.log2_up
   (a *
   2
   ^ b) =
  b +
  Nat.log2_up
   a
Nat.eq_add_1:
  forall
   n
   m : nat,
  n +
  m =
  1 ->
  n =
  1 /\
  m =
  0 \/
  n =
  0 /\
  m =
  1
Nat.log2_mul_pow2:
  forall
   a
   b : nat,
  0 <
  a ->
  0 <=
  b ->
  Nat.log2
   (a *
   2
   ^ b) =
  b +
  Nat.log2
   a
Nat.sqrt_sqrt_up_exact:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt
   a =
  Nat.sqrt_up
   a <->
  (exists
   b : nat,
   0 <=
   b /\
   a =
   b *
   b)
Nat.min_max_antimonotone:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   le
   (Basics.flip
   le))
   f ->
  forall
   x
   y : nat,
  Nat.min
   (f
   x)
   (f
   y) =
  f
   (Nat.max
   x
   y)
Nat.max_min_antimonotone:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   le
   (Basics.flip
   le))
   f ->
  forall
   x
   y : nat,
  Nat.max
   (f
   x)
   (f
   y) =
  f
   (Nat.min
   x
   y)
Nat.div_mod_unique:
  forall
   b
   q1
   q2
   r1
   r2 : nat,
  r1 <
  b ->
  r2 <
  b ->
  b *
  q1 +
  r1 =
  b *
  q2 +
  r2 ->
  q1 =
  q2 /\
  r1 =
  r2
Nat.log2_eq_succ_iff_pow2:
  forall
   a : nat,
  0 <
  a ->
  Nat.log2
   (S
   a) =
  S
   (Nat.log2
   a) <->
  (exists
   b : nat,
   S
   a =
   2
   ^ b)
Nat.eq_add_succ:
  forall
   n
   m : nat,
  (exists
   p : nat,
   n +
   m =
   S
   p) <->
  (exists
   n' : nat,
   n =
   S
   n') \/
  (exists
   m' : nat,
   m =
   S
   m')
Nat.add_bit1:
  forall
   a
   b : nat,
  Nat.testbit
   (a +
   b)
   1 =
  xorb
   (xorb
   (Nat.testbit
   a
   1)
   (Nat.testbit
   b
   1))
   (Nat.testbit
   a
   0 &&
   Nat.testbit
   b
   0)
Nat.testbit_false:
  forall
   a
   n : nat,
  Nat.testbit
   a
   n =
  false <->
  (a /
   2
   ^ n)
  mod 2 =
  0
Nat.log2_unique:
  forall
   a
   b : nat,
  0 <=
  b ->
  2
  ^ b <=
  a <
  2
  ^ 
  S b ->
  Nat.log2
   a =
  b
Nat.gcd_1_lcm_mul:
  forall
   n
   m : nat,
  n <>
  0 ->
  m <>
  0 ->
  Nat.gcd
   n
   m =
  1 <->
  Nat.lcm
   n
   m =
  n *
  m
Nat.sqrt_up_eq_succ_iff_square:
  forall
   a : nat,
  0 <=
  a ->
  Nat.sqrt_up
   (S
   a) =
  S
   (Nat.sqrt_up
   a) <->
  (exists
   b : nat,
   0 <=
   b /\
   a =
   b *
   b)
Nat.testbit_true:
  forall
   a
   n : nat,
  Nat.testbit
   a
   n =
  true <->
  (a /
   2
   ^ n)
  mod 2 =
  1
Nat.mod_mul_r:
  forall
   a
   b
   c : nat,
  b <>
  0 ->
  c <>
  0 ->
  a
  mod 
  (b *
   c) =
  a
  mod b +
  b *
  ((a /
   b)
   mod c)
Nat.le_ind:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   n : nat,
  A n ->
  (forall
   m : nat,
   n <=
   m ->
   A
   m ->
   A
   (S
   m)) ->
  forall
   m : nat,
  n <=
  m ->
  A m
Nat.testbit_bitwise_1:
  forall
   op : 
   bool ->
   bool ->
   bool,
  (forall
   b : bool,
   op
   false
   b =
   false) ->
  forall
   n
   m
   a
   b : nat,
  a <=
  n ->
  Nat.testbit
   (Nat.bitwise
   op
   n
   a
   b)
   m =
  op
   (Nat.testbit
   a
   m)
   (Nat.testbit
   b
   m)
Nat.max_mono:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   f ->
  Morphisms.Proper
   (Morphisms.respectful
   le
   le)
   f ->
  forall
   x
   y : nat,
  Nat.max
   (f
   x)
   (f
   y) =
  f
   (Nat.max
   x
   y)
Nat.log2_up_unique:
  forall
   a
   b : nat,
  0 <
  b ->
  2
  ^ 
  Nat.pred
   b <
  a <=
  2
  ^ b ->
  Nat.log2_up
   a =
  b
Nat.min_mono:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   f ->
  Morphisms.Proper
   (Morphisms.respectful
   le
   le)
   f ->
  forall
   x
   y : nat,
  Nat.min
   (f
   x)
   (f
   y) =
  f
   (Nat.min
   x
   y)
Nat.right_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   z <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  forall
   n : nat,
  z <=
  n ->
  A n
Nat.add3_bits_div2:
  forall
   a0
   b0
   c0 : bool,
  (Nat.b2n
   a0 +
   Nat.b2n
   b0 +
   Nat.b2n
   c0) /
  2 =
  Nat.b2n
   (a0 &&
   b0
   || 
   c0 &&
   (a0
   || b0))
Nat.pow_add_upper:
  forall
   a
   b
   c : nat,
  c <>
  0 ->
  (a +
   b)
  ^ c <=
  2
  ^ 
  Nat.pred
   c *
  (a
   ^ c +
   b
   ^ c)
Nat.right_induction':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   n <=
   z ->
   A
   n) ->
  (forall
   n : nat,
   z <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  forall
   n : nat,
  A n
Nat.lt_ind:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   n : nat,
  A
   (S
   n) ->
  (forall
   m : nat,
   n <
   m ->
   A
   m ->
   A
   (S
   m)) ->
  forall
   m : nat,
  n <
  m ->
  A m
Nat.pair_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  A 0 ->
  A 1 ->
  (forall
   n : nat,
   A
   n ->
   A
   (S
   n) ->
   A
   (S
   (S
   n))) ->
  forall
   n : nat,
  A n
Nat.divide_mul_split:
  forall
   n
   m
   p : nat,
  n <>
  0 ->
  Nat.divide
   n
   (m *
   p) ->
  exists
   q
   r : nat,
   n =
   q *
   r /\
   Nat.divide
   q
   m /\
   Nat.divide
   r
   p
Nat.left_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   n <
   z ->
   A
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  n <=
  z ->
  A n
Nat.testbit_bitwise_2:
  forall
   op : 
   bool ->
   bool ->
   bool,
  op
   false
   false =
  false ->
  forall
   n
   m
   a
   b : nat,
  a <=
  n ->
  b <=
  n ->
  Nat.testbit
   (Nat.bitwise
   op
   n
   a
   b)
   m =
  op
   (Nat.testbit
   a
   m)
   (Nat.testbit
   b
   m)
Nat.add_nocarry_mod_lt_pow2:
  forall
   a
   b
   n : nat,
  Nat.land
   a
   b =
  0 ->
  a
  mod 
  2
  ^ n +
  b
  mod 
  2
  ^ n <
  2
  ^ n
Nat.max_unicity_ext:
  forall
   f : 
   nat ->
   nat ->
   nat,
  (forall
   n
   m : nat,
   n <
   m /\
   f
   n
   m =
   m \/
   m <=
   n /\
   f
   n
   m =
   n) ->
  forall
   n
   m : nat,
  f n
   m =
  Nat.max
   n
   m
Nat.add_nocarry_lt_pow2:
  forall
   a
   b
   n : nat,
  Nat.land
   a
   b =
  0 ->
  a <
  2
  ^ n ->
  b <
  2
  ^ n ->
  a +
  b <
  2
  ^ n
Nat.min_unicity_ext:
  forall
   f : 
   nat ->
   nat ->
   nat,
  (forall
   n
   m : nat,
   n <
   m /\
   f
   n
   m =
   n \/
   m <=
   n /\
   f
   n
   m =
   m) ->
  forall
   n
   m : nat,
  f n
   m =
  Nat.min
   n
   m
Nat.left_induction':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   z <=
   n ->
   A
   n) ->
  (forall
   n : nat,
   n <
   z ->
   A
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  A n
Nat.log2_unique':
  forall
   a
   b
   c : nat,
  0 <=
  b ->
  0 <=
  c <
  2
  ^ b ->
  a =
  2
  ^ b +
  c ->
  Nat.log2
   a =
  b
Nat.log2_spec_alt:
  forall
   a : nat,
  0 <
  a ->
  exists
   r : nat,
   a =
   2
   ^ 
   Nat.log2
   a +
   r /\
   0 <=
   r <
   2
   ^ 
   Nat.log2
   a
Nat.strong_right_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   z <=
   n ->
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   n ->
   A
   n) ->
  forall
   n : nat,
  z <=
  n ->
  A n
Nat.max_min_antimono:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   f ->
  Morphisms.Proper
   (Morphisms.respectful
   le
   (Basics.flip
   le))
   f ->
  forall
   x
   y : nat,
  Nat.max
   (f
   x)
   (f
   y) =
  f
   (Nat.min
   x
   y)
Nat.min_max_antimono:
  forall
   f : 
   nat ->
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   f ->
  Morphisms.Proper
   (Morphisms.respectful
   le
   (Basics.flip
   le))
   f ->
  forall
   x
   y : nat,
  Nat.min
   (f
   x)
   (f
   y) =
  f
   (Nat.max
   x
   y)
Nat.recursion_succ:
  forall
   (A : Type)
   (Aeq : 
   Relation_Definitions.relation
   A)
   (a : A)
   (f : 
   nat ->
   A ->
   A),
  Aeq
   a
   a ->
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   Aeq
   Aeq))
   f ->
  forall
   n : nat,
  Aeq
   (Nat.recursion
   a
   f
   (S
   n))
   (f
   n
   (Nat.recursion
   a
   f
   n))
Nat.strong_left_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   n <=
   z ->
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  n <=
  z ->
  A n
Nat.are_bits:
  forall
   f : 
   nat ->
   bool,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   eq)
   f ->
  (exists
   n : nat,
   Nat.eqf
   f
   (Nat.testbit
   n)) <->
  (exists
   k : nat,
   forall
   m : nat,
   k <=
   m ->
   f
   m =
   false)
Nat.recursion_wd:
  forall
   (A : Type)
   (Aeq : 
   Relation_Definitions.relation
   A),
  Morphisms.Proper
   (Morphisms.respectful
   Aeq
   (Morphisms.respectful
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   Aeq
   Aeq))
   (Morphisms.respectful
   eq
   Aeq)))
   Nat.recursion
Nat.order_induction':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   z <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  (forall
   n : nat,
   n <=
   z ->
   A
   n ->
   A
   (Nat.pred
   n)) ->
  forall
   n : nat,
  A n
Nat.nocarry_equiv:
  forall
   a
   b
   c : nat,
  c /
  2 =
  Nat.lor
   (Nat.land
   a
   b)
   (Nat.land
   c
   (Nat.lor
   a
   b)) ->
  Nat.testbit
   c
   0 =
  false ->
  c =
  0 <->
  Nat.land
   a
   b =
  0
Nat.order_induction:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   z <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  (forall
   n : nat,
   n <
   z ->
   A
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  A n
Nat.strong_right_induction':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   n <=
   z ->
   A
   n) ->
  (forall
   n : nat,
   z <=
   n ->
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   n ->
   A
   n) ->
  forall
   n : nat,
  A n
Nat.order_induction_0:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  A 0 ->
  (forall
   n : nat,
   0 <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  (forall
   n : nat,
   n <
   0 ->
   A
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  A n
Nat.order_induction'_0:
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  A 0 ->
  (forall
   n : nat,
   0 <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  (forall
   n : nat,
   n <=
   0 ->
   A
   n ->
   A
   (Nat.pred
   n)) ->
  forall
   n : nat,
  A n
Nat.strong_left_induction':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   z <=
   n ->
   A
   n) ->
  (forall
   n : nat,
   n <=
   z ->
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  A n
Nat.testbit_unique:
  forall
   (a
   n : nat)
   (a0 : bool)
   (l
   h : nat),
  l <
  2
  ^ n ->
  a =
  l +
  (Nat.b2n
   a0 +
   2 *
   h) *
  2
  ^ n ->
  Nat.testbit
   a
   n =
  a0
Nat.double_induction:
  forall
   R : 
   nat ->
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   R ->
  (forall
   m : nat,
   R
   0
   m) ->
  (forall
   n : nat,
   R
   (S
   n)
   0) ->
  (forall
   n
   m : nat,
   R
   n
   m ->
   R
   (S
   n)
   (S
   m)) ->
  forall
   n
   m : nat,
  R n
   m
Nat.divmod_spec:
  forall
   x
   y
   q
   u : nat,
  u <=
  y ->
  let
   (q',
   u') :=
   Nat.divmod
   x
   y
   q
   u in
  x +
  S y *
  q +
  (y -
   u) =
  S y *
  q' +
  (y -
   u') /\
  u' <=
  y
Nat.rs_rs':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   z <=
   n ->
   A
   n ->
   A
   (S
   n)) ->
  forall
   n : nat,
  z <=
  n ->
  (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   n ->
  A n
Nat.ls_ls':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  A z ->
  (forall
   n : nat,
   n <
   z ->
   A
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  n <=
  z ->
  (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   (S
   n) ->
  A n
Nat.two_dim_induction:
  forall
   R : 
   nat ->
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   R ->
  R 0
   0 ->
  (forall
   n
   m : nat,
   R
   n
   m ->
   R
   n
   (S
   m)) ->
  (forall
   n : nat,
   (forall
   m : nat,
   R
   n
   m) ->
   R
   (S
   n)
   0) ->
  forall
   n
   m : nat,
  R n
   m
Nat.le_ind_rel:
  forall
   R : 
   Relation_Definitions.relation
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   R ->
  (forall
   m : nat,
   R
   0
   m) ->
  (forall
   n
   m : nat,
   n <=
   m ->
   R
   n
   m ->
   R
   (S
   n)
   (S
   m)) ->
  forall
   n
   m : nat,
  n <=
  m ->
  R n
   m
Nat.lt_ind_rel:
  forall
   R : 
   Relation_Definitions.relation
   nat,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   (Morphisms.respectful
   eq
   iff))
   R ->
  (forall
   m : nat,
   R
   0
   (S
   m)) ->
  (forall
   n
   m : nat,
   n <
   m ->
   R
   n
   m ->
   R
   (S
   n)
   (S
   m)) ->
  forall
   n
   m : nat,
  n <
  m ->
  R n
   m
Nat.sqrt_iter_spec:
  forall
   k
   p
   q
   r : nat,
  q =
  p +
  p ->
  r <=
  q ->
  let
   s :=
   Nat.sqrt_iter
   k
   p
   q
   r
   in
  s *
  s <=
  k +
  p *
  p +
  (q -
   r) <
  S s *
  S s
Nat.testbit_spec:
  forall
   a
   n : nat,
  exists
   l
   h : nat,
   0 <=
   l <
   2
   ^ n /\
   a =
   l +
   (Nat.b2n
   (Nat.testbit
   a
   n) +
   2 *
   h) *
   2
   ^ n
Nat.add_carry_div2:
  forall
   (a
   b : nat)
   (c0 : bool),
  (a +
   b +
   Nat.b2n
   c0) /
  2 =
  a /
  2 +
  b /
  2 +
  Nat.b2n
   (Nat.testbit
   a
   0 &&
   Nat.testbit
   b
   0
   || 
   c0 &&
   (Nat.testbit
   a
   0
   || 
   Nat.testbit
   b
   0))
Nat.add_carry_bits:
  forall
   (a
   b : nat)
   (c0 : bool),
  exists
   c : nat,
   a +
   b +
   Nat.b2n
   c0 =
   Nat.lxor
   (Nat.lxor
   a
   b)
   c /\
   c /
   2 =
   Nat.lor
   (Nat.land
   a
   b)
   (Nat.land
   c
   (Nat.lor
   a
   b)) /\
   Nat.testbit
   c
   0 =
   c0
Nat.log2_iter_spec:
  forall
   k
   p
   q
   r : nat,
  2
  ^ 
  S p =
  q +
  S r ->
  r <
  2
  ^ p ->
  let
   s :=
   Nat.log2_iter
   k
   p
   q
   r
   in
  2
  ^ s <=
  k +
  q <
  2
  ^ 
  S s
Nat.ls'_ls'':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   n <=
   z ->
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   (S
   n) ->
   A
   n) ->
  forall
   n : nat,
  (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   n <->
  (fun
   n0 : nat
   =>
   forall
   m : nat,
   m <=
   z ->
   n0 <=
   m ->
   A
   m)
   (S
   n)
Nat.rs'_rs'':
  forall
   A : 
   nat ->
   Prop,
  Morphisms.Proper
   (Morphisms.respectful
   eq
   iff)
   A ->
  forall
   z : nat,
  (forall
   n : nat,
   z <=
   n ->
   (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   n ->
   A
   n) ->
  forall
   n : nat,
  (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   n <->
  (fun
   n0 : nat
   =>
   forall
   m : nat,
   z <=
   m ->
   m <
   n0 ->
   A
   m)
   (S
   n)
